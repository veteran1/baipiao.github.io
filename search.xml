<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>8051ELL库-片内外设篇-定时器</title>
      <link href="2021/03/01/8051ell-ku-pian-nei-wai-she-pian-ding-shi-qi/"/>
      <url>2021/03/01/8051ell-ku-pian-nei-wai-she-pian-ding-shi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>STC8系列MCU有5个十六位定时器/计数器，1个十五位掉电唤醒定时器，部分型号可能有所不同。</p><blockquote><p>定时器/计数器0，工作模式有四种：<code>16位自动重装模式</code>、<code>16位不可重装载模式</code>、<code>8位自动重装载模式</code>、<code>不可屏蔽中断的16位自动重装载模式</code>。有四级中断优先级（0~3），在开启中断后，硬件自动清标志位，不需要软件清理。可编程时钟输出。</p></blockquote><blockquote><p>定时器/计数器1，工作模式有三种：<code>16位自动重装模式</code>、<code>16位不可重装载模式</code>、<code>8位自动重装载模式</code>。有四级中断优先级（0~3），开启中断后，硬件自动清标志位，不需要软件清理。可作为串口1的波特率发生器（12T模式下，波特率最大38400）； 可编程时钟输出。</p></blockquote><blockquote><p>定时器/计数器2,固定工作模式：<code>16位自动重装模式</code>。固定为0级中断优先级，开启中断后，需要软件清中断标志位。可作为串口1~4的波特率发生器（12T模式下，波特率最大38400）；可编程时钟输出。</p></blockquote><blockquote><p>定时器/计数器3,固定工作模式：<code>16位自动重装模式</code>。固定为0级中断优先级，开启中断后，需要软件清中断标志位。可作为串口3的波特率发生器（12T模式下，波特率最大38400）；可编程时钟输出。</p></blockquote><blockquote><p>定时器/计数器4,固定工作模式：<code>16位自动重装模式</code>。固定为0级中断优先级，开启中断后，需要软件清中断标志位。可作为串口4的波特率发生器（12T模式下，波特率最大38400）；可编程时钟输出。</p></blockquote><blockquote><p>掉电唤醒定时器,是一个15位的计数器，用于唤醒处于掉电模式的MCU。</p></blockquote><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-定时器初始化函数"><a href="#1-定时器初始化函数" class="headerlink" title="1. 定时器初始化函数"></a>1. 定时器初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>TIMER0_Init</strong>(const TIMER_InitType * timerx)</td><td align="center">定时器0初始化</td></tr><tr><td align="center">FSCSTATE <strong>TIMER1_Init</strong>(const TIMER_InitType * timerx)</td><td align="center">定时器1初始化</td></tr><tr><td align="center">FSCSTATE <strong>TIMER2_Init</strong>(const TIMER_InitType * timerx)</td><td align="center">定时器2初始化</td></tr><tr><td align="center">FSCSTATE <strong>TIMER3_Init</strong>(const TIMER_InitType * timerx)</td><td align="center">定时器3初始化</td></tr><tr><td align="center">FSCSTATE <strong>TIMER4_Init</strong>(const TIMER_InitType * timerx)</td><td align="center">定时器4初始化</td></tr></tbody></table><h5 id="TIMER-InitType-结构体说明："><a href="#TIMER-InitType-结构体说明：" class="headerlink" title="TIMER_InitType 结构体说明："></a>TIMER_InitType 结构体说明：</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> TIMERType_Type Type<span class="token punctuation">;</span>     <span class="token comment">// 定时器工作类型</span> TIMERMode_Type Mode<span class="token punctuation">;</span>     <span class="token comment">// 定时器工作模式</span> TIMERTCycle_Type TCycle<span class="token punctuation">;</span> <span class="token comment">// 指令周期</span> FUNSTATE ClkOut<span class="token punctuation">;</span>         <span class="token comment">// 可编程时钟输出</span> <span class="token class-name">uint16_t</span> value<span class="token punctuation">;</span>          <span class="token comment">// 定时器定时时间（us）</span> FUNSTATE run<span class="token punctuation">;</span>            <span class="token comment">// 运行标志位</span><span class="token punctuation">&#125;</span> TIMER_InitType<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="TIMERType-Type-枚举体说明："><a href="#TIMERType-Type-枚举体说明：" class="headerlink" title="TIMERType_Type 枚举体说明："></a>TIMERType_Type 枚举体说明：</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">&#123;</span>  TIMER_Type_Timer   <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">,</span>   <span class="token comment">// 作为定时器</span>  TIMER_Type_Counter <span class="token operator">=</span> <span class="token number">0x01</span>     <span class="token comment">// 作为计数器</span><span class="token punctuation">&#125;</span> TIMERType_Type<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="TIMERMode-Type-枚举体说明："><a href="#TIMERMode-Type-枚举体说明：" class="headerlink" title="TIMERMode_Type 枚举体说明："></a>TIMERMode_Type 枚举体说明：</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">&#123;</span>TIMER_16BitAutoReload       <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">,</span>  <span class="token comment">// 模式 0: 十六位自动重装载模式</span>TIMER_16Bit                 <span class="token operator">=</span> <span class="token number">0x01</span><span class="token punctuation">,</span>  <span class="token comment">// 模式 1: 十六位不可重装载模式</span>TIMER_8BitAutoReload        <span class="token operator">=</span> <span class="token number">0x02</span><span class="token punctuation">,</span>  <span class="token comment">// 模式 2: 八位自动重装载模式</span>TIMER_16BitAutoReloadNoMask <span class="token operator">=</span> <span class="token number">0x03</span>   <span class="token comment">// 模式 3: 不可屏蔽中断的十六位自动重装载模式</span><span class="token punctuation">&#125;</span>TIMERMode_Type<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="TIMERTCycle-Type-枚举体说明："><a href="#TIMERTCycle-Type-枚举体说明：" class="headerlink" title="TIMERTCycle_Type 枚举体说明："></a>TIMERTCycle_Type 枚举体说明：</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">&#123;</span>    TIMER_TCY_1T  <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">,</span>   <span class="token comment">//  1T模式: 执行一条指令需要1个周期</span>TIMER_TCY_12T <span class="token operator">=</span> <span class="token number">0x01</span>    <span class="token comment">// 12T模式: 执行一条指令需要12个周期（实际是系统时钟12分频）</span><span class="token punctuation">&#125;</span>TIMERTCycle_Type<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-定时中断初始化函数"><a href="#2-定时中断初始化函数" class="headerlink" title="2. 定时中断初始化函数"></a>2. 定时中断初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE  <strong>NVIC_TIMER0_Init</strong>(NVICPri_Type priority,FUNSTATE run)</td><td align="center">定时器0中断初始化</td></tr><tr><td align="center">FSCSTATE  <strong>NVIC_TIMER1_Init</strong>(NVICPri_Type priority,FUNSTATE run)</td><td align="center">定时器1中断初始化</td></tr><tr><td align="center">FSCSTATE  <strong>NVIC_TIMER2_Init</strong>(FUNSTATE run)</td><td align="center">定时器2中断初始化</td></tr><tr><td align="center">FSCSTATE  <strong>NVIC_TIMER3_Init</strong>(FUNSTATE run)</td><td align="center">定时器3中断初始化</td></tr><tr><td align="center">FSCSTATE  <strong>NVIC_TIMER4_Init</strong>(FUNSTATE run)</td><td align="center">定时器4中断初始化</td></tr></tbody></table><blockquote><p>注：NVICPri_Type 枚举体的具体描述，详情见《中断管理》章节。</p></blockquote><h4 id="3-定时器中断服务函数"><a href="#3-定时器中断服务函数" class="headerlink" title="3. 定时器中断服务函数"></a>3. 定时器中断服务函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void <strong>TIMER0_ISRQ_Handler</strong>(void)</td><td align="center">定时器0中断服务</td></tr><tr><td align="center">void <strong>TIMER1_ISRQ_Handler</strong>(void)</td><td align="center">定时器1中断服务</td></tr><tr><td align="center">void <strong>TIMER2_ISRQ_Handler</strong>(void)</td><td align="center">定时器2中断服务</td></tr><tr><td align="center">void <strong>TIMER3_ISRQ_Handler</strong>(void)</td><td align="center">定时器3中断服务</td></tr><tr><td align="center">void <strong>TIMER4_ISRQ_Handler</strong>(void)</td><td align="center">定时器4中断服务</td></tr></tbody></table><h4 id="4-定时器清中断标志位函数"><a href="#4-定时器清中断标志位函数" class="headerlink" title="4. 定时器清中断标志位函数"></a>4. 定时器清中断标志位函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>TIMER2_CLEAR_FLAG</strong>()</td><td align="center">定时器2清中断标志（宏函数）</td></tr><tr><td align="center"><strong>TIMER3_CLEAR_FLAG</strong>()</td><td align="center">定时器3清中断标志（宏函数）</td></tr><tr><td align="center"><strong>TIMER4_CLEAR_FLAG</strong>()</td><td align="center">定时器4清中断标志（宏函数）</td></tr></tbody></table><h4 id="5-掉电唤醒定时器初始化函数"><a href="#5-掉电唤醒定时器初始化函数" class="headerlink" title="5. 掉电唤醒定时器初始化函数"></a>5. 掉电唤醒定时器初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>TIMER5_Wake_Up_Power</strong>(uint16_t value,FUNSTATE run)</td><td align="center">掉电唤醒定时器初始化</td></tr></tbody></table><p>其参数描述：</p><blockquote><p>Value: 值范围 0 ~ 0x7FFF, 单位us</p></blockquote><blockquote><p>State： ENABLE / DIASBLE</p></blockquote><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><h4 id="1-定时器演示"><a href="#1-定时器演示" class="headerlink" title="1. 定时器演示"></a>1. 定时器演示</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"8051_ELL_Lib.h"</span></span><span class="token keyword">void</span> <span class="token function">STC8x_Config</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    TIMER_InitType TIMER_InitStruct<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">//定义定时器初始化结构体（本函数内只定义一次）</span>        TIMER_InitStruct<span class="token punctuation">.</span>Type <span class="token operator">=</span> TIMER_Type_Timer<span class="token punctuation">;</span>       <span class="token comment">// 工作类型：定时器</span>    TIMER_InitStruct<span class="token punctuation">.</span>Mode <span class="token operator">=</span> TIMER_16BitAutoReload<span class="token punctuation">;</span>  <span class="token comment">// 工作模式：十六位自动重装载</span>    TIMER_InitStruct<span class="token punctuation">.</span>TCycle <span class="token operator">=</span> TIMER_TCY_1T<span class="token punctuation">;</span>  <span class="token comment">// 指令周期：1T模式</span>    TIMER_InitStruct<span class="token punctuation">.</span>ClkOut <span class="token operator">=</span> DISABLE<span class="token punctuation">;</span>  <span class="token comment">// 可编程时钟输出：不输出</span>    TIMER_InitStruct<span class="token punctuation">.</span>Value <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>  <span class="token comment">// 预装载值：1000us</span>    TIMER_InitStruct<span class="token punctuation">.</span>run <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span>  <span class="token comment">// 运行控制位：运行</span>    <span class="token function">TIMER0_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TIMER_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定时器0初始化函数，传入结构体地址              </span>    <span class="token function">NVIC_TIMER0_Init</span><span class="token punctuation">(</span>NVIC_PR0<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定时器0中断初始化函数，优先级为0，开启中断   </span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">STC8x_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">GPIO_MODE_OUT_PP</span><span class="token punctuation">(</span>GPIO_P1<span class="token punctuation">,</span>Pin_0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">TIMER0_ISRQ_Handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token class-name">uint16_t</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token operator">>=</span><span class="token number">500</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        P10 <span class="token operator">!=</span> P10<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-调电唤醒定时器演示"><a href="#2-调电唤醒定时器演示" class="headerlink" title="2. 调电唤醒定时器演示"></a>2. 调电唤醒定时器演示</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;STC8x_TIMER.h&quot;     int main(void)&#123;    TIMER5_Wake_Up_Power(500,ENABLE); &#x2F;* 0.5ms唤醒一次 *&#x2F;    for(;;)    &#123;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库介绍</title>
      <link href="2021/02/18/8051ell-ku-jie-shao/"/>
      <url>2021/02/18/8051ell-ku-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="8051-ELL函数库简介"><a href="#8051-ELL函数库简介" class="headerlink" title="8051 ELL函数库简介"></a>8051 ELL函数库简介</h2><br><p>ELL是<code>efficient low-layer</code>的缩写，意思是<code>高效低封装</code>，结合了<code>HAL库</code>和<code>LL库</code>的编程思想，既保证了通用性又降低了flash的过度占用。可谓是一举两得，高效、简洁、好用！<br><br></p><p>开发函数库，最初是为了满足我自己的生产需求，后来经过深思熟虑，我想做一个好用的通用库，所以把它开源出来，分享给广大工程师们。<br><br></p><p>函数库是基于Keil开发，支持Keil4和Keil5，支持Vscode协同开发，推荐使用EIDE插件。目前函数库主要适配了STC公司的单片机型号，以STC8系列为主。后续计划增加STC12、STC15、STC16系列。<br><br></p><h2 id="新手如何入门"><a href="#新手如何入门" class="headerlink" title="新手如何入门"></a>新手如何入门</h2><br><p>如果你明白了ELL函数库的架构，那么对你学习本库会有非常大的帮助！函数库采用了一个裸机框架来组织库文件。框架包括两大部分：<code>工程文件</code>和<code>库文件</code>。<br><br></p><p>工程文件主要存放<code>Keil工程</code>、<code>Vscode文件</code>、<code>用户代码</code>。这里可以根据你的编程习惯进行安排，非常的自由！库文件才是我们的重头戏，它主要分为四个部分：<code>核心文件夹</code>、<code>片内外设库</code>、<code>组件库</code>、<code>设备驱动库</code>。<br><br></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">核心文件夹：存放各种MCU的寄存器头文件、函数库重定义数据类型头文件、函数库常用数据结构头文件片内外设库：存放MCU的片内外设模块，是库的主要构成单元。组件库：配套8051内核开发的好用组件，具有一定的抽象性和封装性，能加速项目的开发，比如TMT时间片任务进程组件。设备驱动库：一些常用的外围芯片、模块，通过统一的驱动框架进行封装，方便开发。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>下面是ELL函数库的框架图:<br><br></p><img src=" ../../../../images/8051_ell_lib/doc/ELL-framework.png" style="zoom:75%;" /><br><p>关键的是，我们该如何在工程里面使用函数库呢？我们提供了一个非常便捷的方法！我们拿STC8系列的ELL函数库举例，你只需要调用一个头文件<code>8051_ELL_Lib.h</code>，和配置一个头文件<code>Lib_CFG.h</code>。<br><br></p><p>通过配置<code>Lib_CFG.h</code>，可以实现对库裁剪和控制，定制适合你工程的函数库。而使用函数库内的API，只需要调用<code>8051_ELL_Lib.h</code>就可以了。</p><p>看到这里，如果你对本库产生了兴趣，可以通过下面下载:<br><br></p><blockquote><p><a href="https://gitee.com/zeweni/ELL-8051-LIB">gitee仓库  (需要注册账户下载，速度快)</a></p></blockquote><br><blockquote><p><a href="https://github.com/zewen-i/8051-ELL-LIB">github仓库   (可以直接下载，但速度慢)</a></p></blockquote><br><p>本库是开源项目，遵循 Apache 许可证 2.0 版本，可免费在商业产品中使用，不需要公布应用程序源码，没有潜在商业风险。<br><br></p><p>如果本项目对你有所帮助，可以通过下方的<code>赞赏</code>按钮，请我喝一杯咖啡！<br><br></p><blockquote><p>QQ技术交流群：1001220381</p></blockquote><br><p>我会在群里免费答疑和提供技术支持！</p><br>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库工程创建</title>
      <link href="2021/02/18/8051ell-ku-gong-cheng-chuang-jian/"/>
      <url>2021/02/18/8051ell-ku-gong-cheng-chuang-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="工程框架介绍"><a href="#工程框架介绍" class="headerlink" title="工程框架介绍"></a>工程框架介绍</h2><br><p>ELL库使用的工程框架，是我从实验室一步一步更新迭代出来的，这套框架本身是一个裸机框架，但是稍作修改就能作为RTOS的BSP使用，整个框架的结构非常清晰透彻。如果你深入到工程文件结构观察，会发现整个ELL函数库呈现金字塔状分布：</p><img src=" ../../../../images/8051_ell_lib/doc/8051-ELL函数库-金字塔组成.png" style="zoom:75%;" /><br><p>我们从下往上看，最底层有三个部分，分别是：组件库、片内外设库、设备驱动库，三个库构成我们“金字塔”的基石，是ELL函数库的主要内容。<br><br></p><p>往上一层，是每一个库对应的头文件，这些头文件的作用是把三个库里面的模块文件连接起来。<br><br></p><p>再往上一层，是我们的配置头文件，这个文件比较特殊，需要我们自己实现，但是你不要担心，直接拷贝我们的模板工程里提供的就可以，在配置头文件里，主要修改库的一些属性和参数，比如指明我们使用的MCU型号，使能某些组件和设备驱动，这个头文件如果不加入到你的工程种，那么库将会按照默认的配置执行。<br><br></p><p>最上面一层，是我们整个ELL函数库的头文件，它的作用是吧所有模块链接起来，所以我们只要调用这一个头文件，就可以使用库里面的所用模块，当然有些功能需要在配置头文件里修改参数才能启动。<br><br></p><h2 id="框架设计哲学"><a href="#框架设计哲学" class="headerlink" title="框架设计哲学"></a>框架设计哲学</h2><br><p>在这里你可能有疑问，为什么我要设计一个这样的工程框架，或者说叫裸机框架（和RTOS的BSP做区分）？<br><br></p><p>我刚开始写代码的时候，都是用一个头文件包罗万象，各种模块从到到尾全都丢到一起include，方便又省事。但这样的结果是，导致工程管理混乱，代码写得越多，一出问题就越难排查。<br><br></p><p>所以考虑到以上种种问题，我做了这样的设计，ELL函数库的每一个模块必须是独立的，各模块之间的耦合性要降到最低。在C语言里，管理模块之间的联系，最好的办法是通过头文件来实现，但这里我们要注意一些细节：</p><blockquote><p>头文件尽量不要重复包含。尽管我们有预编译指令<code>#ifndef</code>，但我还是建议从源头就规避，因为我们要考虑编译器是如何执行编译的，给编译器减轻负担，就是给我们提高编译效率和速度。</p></blockquote><blockquote><p>头文件的包含，一定要有层级概念。最好是一层一层的包含上去，最底层的不要包含最上层的头文件，就好比我们库金字塔结构的示意图，最下面一层的C文件里，不能包含最顶层库的头文件。在Keil C51里，头文件任意包含，很容易出现问题，导致编译失败，包含的头文件越多越复杂，越容易出现问题。</p></blockquote><br><p>除了头文件，我们对源文件也要采取一定的管理措施。最基本的就是高内聚低耦合，减少全局变量的使用，即使用到全局变量，也尽量缩小其作用域，限制在本模块以内。<br><br></p><p>如果遇到模块之间的配合调用，那么我们需要把相关信息，封装在头文件内，如果需要跨文件调用函数，那么被调用函数的作用域，要仅限在作用函数以内。<br><br></p><h2 id="从零开始建工程"><a href="#从零开始建工程" class="headerlink" title="从零开始建工程"></a>从零开始建工程</h2><br><p>接下来我们讲工程的建立，这里使用的方法，适用于所有的51单片机。正式开始之前，我先讲一些Keil-C51的软件功能，帮大家补一些知识盲区，还有平常不注意的地方，这也是接下来建工程会用到的知识。<br><br></p><ul><li><strong>Keil C51 的版本问题</strong><br></li></ul><p>老工程师比较喜欢用Keil4，因为它简单易用。但Keil4有一些功能缺陷，尤其是代码编写方面，非常令人头疼。它没有代码补全、中文字符字符编码容易乱码、稳定性“差”。我觉得稳定性不是Keil4的错，这要归结于对操作系统的兼容性，很多老软件都有这种问题。<br><br></p><p>那Keil5就足够优秀了吗，不见得。依旧没有代码补全功能，因此在库开发，常遇到使用大量API函数时，对于没有代码补全的IDE来说，是非常麻烦的。<br><br></p><p>但是，作为一名好的工程师，我们的能力，就体现在把不好用的工具用好了！所以在正确看待IDE的不足以后，我们要好好珍惜那些它做的还不错的地方。<br><br></p><ul><li><strong>Keil C51 的预备知识</strong><br></li></ul><p>不管是Keil4 还是Keil5 我们都要搞明白，同一个版本的Keil有好几个方向，有面向8051的、有面向ARM的等等。对于8051内核的MCU，我们要选择安装Keil C51的IDE。<br><br></p><p>安装Keil4和Keil5都可以，但是要注意，Keil4的版本尽量选择新一点，一定要包含LX51功能,如果你不知道如何选择，我给你推荐一个版本Keil C51 V901，可以加QQ群<code>1001220381</code>免费获取，Keil5的话就随你自己选择了,我们库开发使用的是 Keil C51 V960，加群同样可下载。<br><br></p><p>为什么一定要包含LX51功能？这就要讲一下Keil的编译需要那些模块来完成。</p><blockquote><ul><li>C51国际标准化C交叉编译器：<br>从8051C源代码产生可以重定位的目标模块</li></ul></blockquote><blockquote><ul><li>BL51连接器/定位器：<br>组合由C51和A51产生的可重定位的目标模块，产生绝对目标模块。 </li></ul></blockquote><blockquote><ul><li>A51宏编译器：<br>从8051汇编源代码代码产生就可以重定位的目标模块</li></ul></blockquote><blockquote><ul><li>OH51目标文件至Hex格式的转换器：<br>从绝对目标文件生成Hex文件</li></ul></blockquote><p>通过上述功能模块，就能实现Keil最基本的定位目标模块、链接、生成Hex烧录文件等编译流程。这其中的BL51、A51就是我们做学问的地方。一般情况下，Keil会把我们源文件内的所有代码都编译出来（预编译部分除外），但这会导致最后生成Hex文件过大。<br><br></p><p>有的人会选择，把没用到的代码注释掉，来解决这个问题。但对于库开发来说，这样是出力不讨好的。解决办法也很简单，只需要在配置界面的【BL51 Misc】中<strong>Misc control</strong>框内输入:<code>NOOVERLAY</code>即可。<br><br></p><img src=" ../../../../images/8051_ell_lib/doc/BL51.jpg" style="zoom:75%;" /><br><p>然而，这样的效果并没有太好，编译后的Hex文件仍然不小（虽然可以调整优化等级，但是不建议级别太高）。幸好Keil为我们提供了解决办法：</p><blockquote><ul><li>LX51连接器/定位器：<br>BL51的超集，提供更完善更优化的代码链接功能，生成的Hex文件大大减小（相比之下有8%的体积优化）。 </li></ul></blockquote><blockquote><ul><li>AX51宏编译器：<br>A51的超集，提供更完善更优化的代码编译功能，生成的Hex文件大大减小。</li></ul></blockquote><p>除此之外，<strong>LX51链接器</strong>最多可支持8 Mbytes的 代码和8 Mbytes的空间数据，能编译更大的源代码。<br><br></p><p>同时提供详细数据类型检查，在编译生成的所有程序目标中包含详细的信息(如变量、函数、函数的参数列表、单元、结构，等等)。 LX51链接器在目标模块中进行比较并报告任何不匹配。 这有助于在函数的声明或结构或变量中找到细微的错误。<br><br></p><p>尽管如此，我们还需要一点配置手段，才能让<strong>LX51链接器</strong>只编译我们调用过和相关联的代码。在配置界面的【LX51 Misc】中<strong>Misc control</strong>框内输入:<code>REMOVEUNUSED</code>即可。<br><br></p><img src=" ../../../../images/8051_ell_lib/doc/LX51.jpg" style="zoom:75%;" /><br><p>好了，在了解Keil如何编译工程以后，我们就可以开始建立工程了。这里提供三种方法，分别是Keil工程创建、VsCode协同开发、VsCode工程创建。你可以根据自己的喜好来选择，但不管怎么样，都需要你先创建一个Keil工程。</p><blockquote><p>Keil工程创建</p></blockquote><ul><li>准备工作：Keil4或Keil5、STC-ISP助手、8051 ELL函数库</li><li>优点：提供丰富细致的配置，完善的debug、仿真、烧录功能</li><li>缺点：没有代码补全，交互界面陈旧</li></ul><br><p>这里我选择Keil5，STC-ISP助手v6.88，如果你怕出现问题，就选择和我一样的版本,STC型号选择STC8A8K64S4A12。<br><br></p><p><strong>1. 安装STC的芯片包</strong><br><br></p><p>打开STC-ISP助手，选择<code>Keil仿真设置</code>，按照下图操作后，成功就会弹窗<code>STC MCU芯片型号添加成功！</code>。注意，选择Keil的根目录时，只要到最顶层的Keil路径就可以了。<br><br></p><img src=" ../../../../images/8051_ell_lib/doc/STC-ISP-device.jpg" style="zoom:75%;" /><br><p><strong>2. 创建Keil空白工程</strong><br><br></p><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-1.jpg" style="zoom:75%;" /><br><p>在窗口里面选择一个路径，我这里选择桌面，并新建一个文件夹，命名为<code>Keil_Demo</code>。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-2.jpg" style="zoom:75%;" /><br><br></p><p>在gitee或者github仓库下载好ELL函数库，将<code>libraries</code>拷贝过来，同时新建一个文件夹，命名为<code>project</code>。</p><ul><li><a href="https://gitee.com/zeweni/ELL-8051-LIB">gitee仓库  (需要注册账户下载，速度快)</a></li><li><a href="https://github.com/zewen-i/8051-ELL-LIB">github仓库   (可以直接下载，但速度慢)</a></li></ul><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-3-1.jpg" style="zoom:75%;" /><br><p>点击进入project文件夹，新建文件夹<code>build</code>用来存放编译文件，新建文件夹<code>main</code>用来存放MCU初始化文件、新建文件夹<code>app</code>用来我们自己写的代码。最后在输入框给工程起一个名称，这里命名为<code>Demo</code>，然后点击保存（图里面在后面建好了，这里先把文件夹都创建好）。</p><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-3-2.jpg" style="zoom:75%;" /><br><p>Keil工程会跳出Device选择界面，按照下图操作：<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-4.jpg" style="zoom:75%;" /><br><br></p><p>选择否，不需要添加汇编文件（这是一个启动文件，这里不需要）。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-5.jpg" style="zoom:75%;" /><br><br></p><p>点击左上方的魔术棒，我们来配置工程的基本属性，从左到右依次点击选项卡。先选择<code>Target</code>，按图进行配置。根据STC8A的内存容量，所以我们选择XDATA、64Kprogram。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-6.jpg" style="zoom:75%;" /><br><br></p><p>选择<code>output</code>，按图进行操作，要注意必须点击进<code>build</code>文件夹里面，这个路径设置才能生效，这一步主要是为了统一管理输出文件。最后设置好路径以后，别忘了勾选生成Hex文件的复选框。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-7.jpg" style="zoom:75%;" /><br><br></p><p>选择<code>Listing</code>，按图进行操作，同样选择<code>build</code>文件夹的路径，这样我们放在一起，不用额外一个文件夹了。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-8.jpg" style="zoom:75%;" /><br><br></p><p>选择<code>C51</code>，按图中所示步骤，将文件夹<code>libraries</code>下的文件夹路径添加进来，你可以点击这个图放大后进行对照操作，不要有所遗漏。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-9.jpg" style="zoom:75%;" /><br><br></p><p>选择<code>LX51 Misc</code>，在图中所示位置输入<code>REMOVEUNUSED</code>。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-10.jpg" style="zoom:75%;" /><br><br></p><p>选择<code>dewbug</code>,如果你暂时不需要外部硬件调试，可以跳过这一步，如果需要就按图设置，要注意这里还需要点击<code>setting</code>，如果你使用串口仿真调试，就选择对应的COM口，并把波特率设置为115200。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-11.jpg" style="zoom:75%;" /><br><br></p><p>点击左上方图中示意的图标，然后按图创建所示分支，并把每个分支下的内容添加进来，可以点击图片放大观看，方便对应。<br>提示：如果你只需要片内外设库，那么只添加<code>lib/peripheral</code>下对应的C文件就好了。</p><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-12.jpg" style="zoom:75%;" /><br><p>回到主界面，我们双击左边栏目中的main选项分支，就可以添加文件，我们选择之前创建好的main文件夹，在里面创建<code>main.c</code>文件，并添加进来。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-13.jpg" style="zoom:75%;" /><br><br></p><p>在我们的gitee放库中，选择<code>projetc</code>-&gt;<code>STC8Ax</code>-&gt;<code>main</code>-&gt;<code>Lib_CFG.h</code>,拷贝到我们的main文件夹下，并把它添加进来。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-14.jpg" style="zoom:75%;" /><br><br></p><p>在main.c中编写如下代码,并点击左上方的<code>buiid</code>进行编译，如果出现图中端提示的内容，就证明你工程创建成功啦！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;8051_ELL_Lib.h&quot;int main(void)&#123;for(;;)&#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-15.jpg" style="zoom:75%;" /><br><p>按照如上步骤，就可以创建一个ELL函数库工程，如果你不想如此繁琐的创建工程，只需要下载gitee或者github的仓库，里面有现成的Keil工程，直接在此基础上使用即可。</p><p>注意事项：</p><ul><li>工程下的文件，如果变动位置或者修改名称，都需要在Keil的配置界面<code>C51</code>中重新配置该文件或者文件的路径，同时在主界面左边的工程树中，重新导入修改的文件。</li></ul><blockquote><p>VsCode协同开发</p></blockquote><ul><li>准备工作：ELL函数Keil工程一份、VsoCode、VsCode C/C++插件、VsCode Keil Assistant插件</li><li>优点：提供代码补全功能，人机交互做的非常好</li><li>缺点：没有debug功能，需要配合Keil使用，需要通过Keil来向工程添加新的文件，</li></ul><br><p><strong>1. 安装VsCode 插件</strong><br><br></p><p>点击左边的<code>应用商店</code>，安装<code>C/C++</code>、<code>Chinese</code>、<code>Keil Assistant</code>。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-h-1.jpg" style="zoom:75%;" /><br><br></p><p><strong>2. 配置Keil Assistant插件</strong><br><br></p><p>点击<code>Keil Assistant</code>的设置图标,选择<code>扩展设置</code>。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-h-2.jpg" style="zoom:75%;" /><br><br></p><p>导入Keil的执行文件路径，注意路径最后面要加.exe。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-h-3.jpg" style="zoom:75%;" /><br><br></p><p><strong>3. 导入Keil工程，进行协同开发</strong><br><br></p><p>导入Keil工程所在的文件夹。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-h-4.jpg" style="zoom:75%;" /><br><br></p><p>通过图示，点击<code>+</code>按钮，将工程文件打开。注意，不能使用VsCode直接打开Keil工程文件，必须通过这个插件来打开。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-h-5.jpg" style="zoom:75%;" /><br><br></p><p>在Keil Assistant插件的页面，可以对工程进行预览、编译，如果你需要向工程添加文件，需要回到Keil里面操作，Debug也是。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-h-6.jpg" style="zoom:75%;" /><br><br></p><blockquote><p>VsCode工程创建</p></blockquote><ul><li>准备工作：ELL函数Keil工程一份、VsoCode、VsCode C/C++插件、Embedded IDE插件</li><li>优点：提供代码补全功能，人机交互做的非常好，提供多种工具链，可以修改工程，进行编译、调试</li><li>缺点：部分依赖Keil调试的芯片，没有debug功能</li></ul><p><strong>1. 安装VsCode 插件</strong><br><br></p><p>点击左边的<code>应用商店</code>，安装<code>C/C++</code>、<code>Chinese</code>、<code>Embedded IDE</code>。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-P-1.jpg" style="zoom:75%;" /><br><br></p><p><strong>2. 配置Embedded IDE插件</strong><br><br></p><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-P-2.jpg" style="zoom:75%;" /><br><p>打开Keil的根目录，选择<code>TOOLS.INI</code>文件。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-P-3.jpg" style="zoom:75%;" /><br><br></p><p><strong>3. 导入Keil工程，生成EIDE工程</strong><br><br></p><p>按图所示，导入Keil工程。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-P-4.jpg" style="zoom:75%;" /><br><br></p><p>选择与Keil工程放在同一个文件夹下，方便管理项目。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-P-6.jpg" style="zoom:75%;" /><br><br></p><p>修改配置文件，因为我们的工程使用的是STC8A8K64S4A12，所以选择RAM大容量。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-P-6.jpg" style="zoom:75%;" /><br><br></p><p>编译工程，看到如下信息，就表示我们工程创建成功了。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-P-7.jpg" style="zoom:75%;" /><br><br></p><ul><li>补充：EIDE插件还支持SDCC 和stcgal，可以完全脱离Keil开发，如果你感兴趣可以尝试一下。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Altium Designer 20 笔记（一） 创建工程</title>
      <link href="2021/02/18/altium-designer-20-bi-ji-yi-ad-gong-cheng-zu-cheng-ji-chuang-jian/"/>
      <url>2021/02/18/altium-designer-20-bi-ji-yi-ad-gong-cheng-zu-cheng-ji-chuang-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="Altium-Designer介绍"><a href="#Altium-Designer介绍" class="headerlink" title="Altium Designer介绍"></a>Altium Designer介绍</h2><p>Altium Designer 是原Protel软件开发商Altium公司推出的一体化的电子产品开发系统，主要运行在Windows操作系统。</p><p>这套软件通过把原理图设计、电路仿真、PCB绘制编辑、拓扑逻辑自动布线、信号完整性分析和设计输出等技术的完美融合，为设计者提供了全新的设计解决方案，使设计者可以轻松进行设计，熟练使用这一软件使电路设计的质量和效率大大提高。</p><h2 id="AD20-基本工程介绍"><a href="#AD20-基本工程介绍" class="headerlink" title="AD20 基本工程介绍"></a>AD20 基本工程介绍</h2><p>AD20的工程组成基本如下：</p><img src=" ../../../../images/ad20_note/note1/工程文件组成.jpg" style="zoom:50%;" /><p>一个工程最核心的文件是原理图和PCB，与其相搭配的是这两种文件对应的库，之后是各种生成文件。</p><h2 id="AD20-工程创建流程"><a href="#AD20-工程创建流程" class="headerlink" title="AD20 工程创建流程"></a>AD20 工程创建流程</h2><h5 id="首先，我们要创建一个空的工程项目"><a href="#首先，我们要创建一个空的工程项目" class="headerlink" title="首先，我们要创建一个空的工程项目"></a>首先，我们要创建一个空的工程项目</h5><p>选择 <code>文件</code> -&gt; <code>新的..</code> -&gt;  <code>项目</code></p><img src=" ../../../../images/ad20_note/note1/新建工程.jpg" style="zoom:50%;" /><h5 id="接着，我们要选择工程类型"><a href="#接着，我们要选择工程类型" class="headerlink" title="接着，我们要选择工程类型"></a>接着，我们要选择工程类型</h5><p>选择 <code>PCB</code> -&gt; <code>Default</code></p><img src=" ../../../../images/ad20_note/note1/工程类型页面.jpg" style="zoom:50%;" /><p>一般设计画电路板，我们选择PCB选项。点击到<code>PCB</code>这个选项展开，defult选项是由我们自建工程属性，其他的选项，是软件预先帮我们设计好的demo工程。</p><h5 id="给工程命名和设置存放路径"><a href="#给工程命名和设置存放路径" class="headerlink" title="给工程命名和设置存放路径"></a>给工程命名和设置存放路径</h5><p>选择 <code>PCB</code> -&gt; <code>Default</code></p><img src=" ../../../../images/ad20_note/note1/工程类型页面-配置属性.jpg" style="zoom:75%;" /><p>路径一定要重新设置，默认是指向AD的根目录或者默认的工作区的。</p><p>工程名字根据自己习惯命名。</p><h5 id="给工程创建原理图和库"><a href="#给工程创建原理图和库" class="headerlink" title="给工程创建原理图和库"></a>给工程创建原理图和库</h5><p>选择 <code>文件</code> -&gt; <code>新的..</code> -&gt; <code>库</code> -&gt; <code>原理图库</code> 和 <code>PCB元件库</code></p><p>选择 <code>文件</code> -&gt; <code>新的..</code> -&gt; <code>原理图</code> 和 <code>PCB</code></p><img src=" ../../../../images/ad20_note/note1/主页面-创建库.jpg" style="zoom:75%;" /><p>如果你有自己的库，可以先不创建库，直接创建原理图，后面再把库导入进来。PCB我们也可以不用先创建，画好原理图后，再创建也不迟。</p><p><strong>特别强调，每一个文件建好以后，都要保存 ctrl+s快捷键保存。</strong></p><p>文件保存的路径默认是工程的路径。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><img src=" ../../../../images/ad20_note/note1/工程树.jpg" style="zoom:75%;" /><p>一般我们创建完毕工程以后，就是四个文件：<code>原理图</code>、<code>PCB</code>、<code>原理图库</code>、<code>PCB元件库</code>。后两个库如果有现成的，可以直接导入进来。</p><p>我们在初次创建工程的时候，可能遇到的问题有：</p><ul><li>工程路径没有设置好，导致下次找不到工程文件；</li><li>工程下的各文件是单独建立的，导致各文件没有产生正确的依赖关系，比如原理图无法更新到PCB中；</li><li>文件建立以后，没有及时保存，导致工程树中看不到。</li></ul>]]></content>
      
      
      <categories>
          
          <category> AD20使用指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCB设计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
