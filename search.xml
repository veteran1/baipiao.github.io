<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>8051ELL库-片内外设篇-MDU16</title>
      <link href="2021/03/16/8051ell-ku-pian-nei-wai-she-pian-mdu16/"/>
      <url>2021/03/16/8051ell-ku-pian-nei-wai-she-pian-mdu16/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>STC8系列MCU的部分型号，内部集成了16位的硬件乘除单元，可以做一个数据处理，大幅度提高单片机算力性能。</p><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-十六位乘法"><a href="#1-十六位乘法" class="headerlink" title="1. 十六位乘法"></a>1. 十六位乘法</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>MUL_16_BIT</strong>(mol, den, quo, rem)</td><td align="center">十六位乘法</td></tr></tbody></table><p><strong>mul1</strong>：乘数1<br><strong>mul1</strong>：乘数2<br><strong>pro</strong>：乘积</p><br><h4 id="2-十六位除法"><a href="#2-十六位除法" class="headerlink" title="2. 十六位除法"></a>2. 十六位除法</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>DIV_16_BIT</strong>(mol, den, quo, rem)</td><td align="center">十六位除法</td></tr></tbody></table><p><strong>mol</strong>：分子<br><strong>den</strong>：分母<br><strong>quo</strong>：商<br><strong>rem</strong>：余数</p><br><h4 id="3-三十二位除法"><a href="#3-三十二位除法" class="headerlink" title="3. 三十二位除法"></a>3. 三十二位除法</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>DIV_16_BIT</strong>(mol, den, quo, rem)</td><td align="center">三十二位除法</td></tr></tbody></table><p><strong>mol</strong>：分子<br><strong>den</strong>：分母<br><strong>quo</strong>：商<br><strong>rem</strong>：余数</p><br><h4 id="4-数据左移"><a href="#4-数据左移" class="headerlink" title="4. 数据左移"></a>4. 数据左移</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>MOVE_LEFT_SHIFT</strong>(mdata, digits, result)</td><td align="center">数据左移</td></tr></tbody></table><p><strong>mdata</strong>：需要移动的数据<br><strong>digits</strong>：移动的位数<br><strong>result</strong>：结果</p><br><h4 id="5-数据右移"><a href="#5-数据右移" class="headerlink" title="5. 数据右移"></a>5. 数据右移</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>MOVE_RIGHT_SHIFT</strong>(mdata, digits, result)</td><td align="center">数据右移</td></tr></tbody></table><p><strong>mdata</strong>：需要移动的数据<br><strong>digits</strong>：移动的位数<br><strong>result</strong>：结果</p><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;8051_ELL_Lib.h&quot;int main(void)&#123;    uint32_t mol,den,quo,rem;    mol &#x3D; 1000000;    den &#x3D; 1000;    quo &#x3D; 0;    rem &#x3D; 0;    void STC8x_System_Init();    DIV_16_BIT(mol, den, quo,rem);    printf(&quot;%d&quot;,rem);    for(;;)    &#123;           &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-片内外设篇-SPI</title>
      <link href="2021/03/16/8051ell-ku-pian-nei-wai-she-pian-spi/"/>
      <url>2021/03/16/8051ell-ku-pian-nei-wai-she-pian-spi/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>SPI是一种全双工的高速通信总线。STC8内部集成了一个SPI外设，支持主机和从机两种模式。</p><p>SPI的通信一般有三种：单主单从、互为主从、单主多从。具体实现方式和原理，可参照STC8的技术手册。</p><p>函数库为了最大限度保证SPI外设的应用灵活性，只保留对外设的配置和初始化，以及基本的操作函数，开发者可以根据需求，自行编写SPI通信应用，以便应对复杂多样的芯片模块。</p><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-SPI初始化函数"><a href="#1-SPI初始化函数" class="headerlink" title="1. SPI初始化函数"></a>1. SPI初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>SPI_Init</strong>(SPIInit_Type *SPIx)</td><td align="center">SPI初始化</td></tr></tbody></table><br><h5 id="SPIInit-Type-结构体说明"><a href="#SPIInit-Type-结构体说明" class="headerlink" title="SPIInit_Type  结构体说明"></a>SPIInit_Type  结构体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct &#123;  SPIType_Type Type;  &#x2F;&#x2F;SPI通讯类型选择  SPIClkSrc_Type ClkSrc; &#x2F;&#x2F;SPI时钟源选择（外设通信速度）  SPIMode_Type Mode;  &#x2F;&#x2F;SPI模式  SPITran_Type Tran;  &#x2F;&#x2F;SPI发送方式  FUNSTATE run;    &#x2F;&#x2F;SPI运行控制位&#125; SPIInit_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="SPIType-Type-枚举体说明"><a href="#SPIType-Type-枚举体说明" class="headerlink" title="SPIType_Type 枚举体说明"></a>SPIType_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;  SPI_Type_Master &#x3D; 0x90,    &#x2F;&#x2F;主机模式  SPI_Type_Slave  &#x3D; 0x80,    &#x2F;&#x2F;从机模式  SPI_Type_Master_Slave &#x3D; 0x00   &#x2F;&#x2F;互为主从机模式&#125; SPIType_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="SPIClkSrc-Type-枚举体说明"><a href="#SPIClkSrc-Type-枚举体说明" class="headerlink" title="SPIClkSrc_Type 枚举体说明"></a>SPIClkSrc_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;  SPI_SCLK_DIV_4  &#x3D; 0x00,  &#x2F;&#x2F;系统时钟4分频  SPI_SCLK_DIV_8  &#x3D; 0x01,  &#x2F;&#x2F;系统时钟8分频  SPI_SCLK_DIV_16 &#x3D; 0x02,  &#x2F;&#x2F;系统时钟16分频  SPI_SCLK_DIV_32 &#x3D; 0x03   &#x2F;&#x2F;系统时钟32分频&#125; SPIClkSrc_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="SPITran-Type-枚举体说明"><a href="#SPITran-Type-枚举体说明" class="headerlink" title="SPITran_Type 枚举体说明"></a>SPITran_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;  SPI_Tran_MSB &#x3D; 0x00,   &#x2F;&#x2F;高字节在前  SPI_Tran_LSB  &#x3D; 0x01   &#x2F;&#x2F;低字节在前&#125; SPITran_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="SPIMode-Type-枚举体说明"><a href="#SPIMode-Type-枚举体说明" class="headerlink" title="SPIMode_Type 枚举体说明"></a>SPIMode_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;  SPI_Mode_0  &#x3D; 0x00,  &#x2F;&#x2F;SPI模式0  SPI_Mode_1  &#x3D; 0x01,  &#x2F;&#x2F;SPI模式1  SPI_Mode_2  &#x3D; 0x02,  &#x2F;&#x2F;SPI模式2  SPI_Mode_3  &#x3D; 0x03   &#x2F;&#x2F;SPI模式3&#125; SPIMode_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="2-SPI操作函数"><a href="#2-SPI操作函数" class="headerlink" title="2. SPI操作函数"></a>2. SPI操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>SPI_Send_ data</strong>(uint8_t  dat)</td><td align="center">SPI发送数据（一个字节）</td></tr><tr><td align="center">FSCSTATE <strong>SPI_Rev_ data</strong>(uint8_t *  dat)</td><td align="center">SPI接收数据（一个字节）</td></tr></tbody></table><br><h4 id="3-SPI端口切换函数"><a href="#3-SPI端口切换函数" class="headerlink" title="3. SPI端口切换函数"></a>3. SPI端口切换函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>GPIO_SPI_SWPort</strong>(GPIOSWPort_Type Port);</td><td align="center">SPI端口切换</td></tr></tbody></table><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;8051_ELL_Lib.h&quot;void STC8x_SPI_Config(void)&#123;    SPIInit_Type SPI_InitStruct&#x3D;&#123;0&#125;;        SPI_InitStruct.Type &#x3D; SPI_Type_Master;  &#x2F;&#x2F;SPI选择主机模式    SPI_InitStruct.ClkSrc &#x3D; SPI_SCLK_DIV_4;  &#x2F;&#x2F;SPI选择4分频    SPI_InitStruct.Mode &#x3D; SPI_Mode_0;   &#x2F;&#x2F;SPI工作在模式0    SPI_InitStruct.Tran &#x3D; SPI_Tran_MSB; &#x2F;&#x2F;SPI高字节在前发送    SPI_InitStruct.run &#x3D; ENABLE;  &#x2F;&#x2F;使能SPI运行    SPI_Init(&amp;SPI_InitStruct);&#125;int main(void)&#123;    uint8_t  dat &#x3D; &#39;A&#39;;    STC8x_SPI_Config();    SPI_Send_ data( dat);    for(;;)    &#123;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>补充：这里SPI的应用，可以参照设备驱动库oled的源代码。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-片内外设篇-I2C</title>
      <link href="2021/03/16/8051ell-ku-pian-nei-wai-she-pian-i2c/"/>
      <url>2021/03/16/8051ell-ku-pian-nei-wai-she-pian-i2c/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>I2C是一种高速同步通讯总线，STC8内部集成了一个I2C通信外设，但是相比标准I2C协议，忽略了两种机制：</p><ul><li>发送起始信号（START）以后不进行仲裁</li><li>时钟信号（SCL）停留在低电平时不进行超时检测</li></ul><p>STC8的I2C总线提供了两种操作模式：主机模式和从机模式。ELL提供了I2C的基本操作函数，包括初始化和各种信号的操作函数，开发者可以在此基础上灵活编写通信应用。</p><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-I2C初始化函数"><a href="#1-I2C初始化函数" class="headerlink" title="1. I2C初始化函数"></a>1. I2C初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>I2C_Init</strong>(I2CType_Type Type, uint8_t wTime, FUNSTATE state)</td><td align="center">I2C初始化</td></tr></tbody></table><p><strong>wTime：</strong> I2C操作等待时间</p><p><strong>state：</strong> I2C运行使能控制</p><br><h5 id="I2CType-Type-枚举体说明"><a href="#I2CType-Type-枚举体说明" class="headerlink" title="I2CType_Type  枚举体说明"></a>I2CType_Type  枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;  I2C_Type_Master &#x3D; 0x01,  &#x2F;&#x2F;I2C主机模式  I2C_Type_Slave  &#x3D; 0x00   &#x2F;&#x2F;I2C从机模式&#125; I2CType_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="2-I2C操作函数"><a href="#2-I2C操作函数" class="headerlink" title="2. I2C操作函数"></a>2. I2C操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>I2C_Start</strong>(void)</td><td align="center">I2C开始信号</td></tr><tr><td align="center">FSCSTATE <strong>I2C_Stop</strong>(void)</td><td align="center">I2C停止信号</td></tr><tr><td align="center">FSCSTATE <strong>I2C_Send_ACK</strong>(void)</td><td align="center">I2C发送ACK信号</td></tr><tr><td align="center">FSCSTATE <strong>I2C_Send_NAK</strong>(void)</td><td align="center">I2C发送NAK信号</td></tr><tr><td align="center">FSCSTATE <strong>I2C_Read_ACK</strong>(void)</td><td align="center">I2C读ACK信号</td></tr><tr><td align="center">FSCSTATE <strong>I2C_Send_Byte</strong>(uint8_t  dat)</td><td align="center">I2C发送数据</td></tr><tr><td align="center">uint8_t <strong>I2C_Read_Byte</strong>(void)</td><td align="center">I2C读取数据</td></tr></tbody></table><br><h4 id="3-I2C端口切换函数"><a href="#3-I2C端口切换函数" class="headerlink" title="3. I2C端口切换函数"></a>3. I2C端口切换函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>GPIO_I2C_SWPort</strong>(GPIOSWPort_Type Port);</td><td align="center">I2C端口切换</td></tr></tbody></table><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>此处暂不提供代码演示，后续会通过设备驱动库的模块来演示。</p>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-片内外设篇-12位ADC</title>
      <link href="2021/03/16/8051ell-ku-pian-nei-wai-she-pian-12-wei-adc/"/>
      <url>2021/03/16/8051ell-ku-pian-nei-wai-she-pian-12-wei-adc/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>STC8系列MCU有一个12位高速ADC，速度最快可达到系统时钟频率/2。</p><blockquote><p><strong>ADC转换速度</strong>（工作时钟频率）的范围在 SysClk/2/1 ~ SysClk/2/16 之间。</p></blockquote><blockquote><p><strong>ADC通道</strong> 有16个通道（0~15），P0.0到P0.6，P1.0到P1.7，15通道只能测量内部1.344V参考电压（有1%误差）。</p></blockquote><blockquote><p><strong>数据格式</strong> ADC转换结果的数据格式，有两种，分别是左对齐和右对齐。</p></blockquote><p><strong>注意事项</strong></p><p>MCU与ADC相关的引脚 AVCC、AGND、AVREF<strong>一定不能浮空</strong>。在对精度不高的要求下，可以将AVCC、AVREF连接VCC、AGND连接GND。</p><p>在ADC的电源启动以后，对应的通道IO口，就对被强制设置成高阻输入模式，并关闭此端口上的数字输入通道（其他复用功能全部失效），不过建议在初始化之前，就将IO口设置成高阻输入模式。</p><p>并且由于ADC对应的15路通道IO口，均有复用功能，所以为了避免打开ADC电源的同时，不影响不相关IO的数字功能，建议对ADC电源和通道进行同时设置和选择。如果要对多个通道分时复用，那么可以先设置为一个通道，在采集信号的时候，再分时选择另一个通道。</p><p>以上注意事项，可在代码演示中看到相关例程说明。</p><p>同时要牢记，不同的型号ADC的通道引脚有所不同，不过ELL库已经适配了大部分，但是由于数量较多，为防止遗漏和错误，谨慎起见，还请开发者对照官方数据手册操作。</p><p><strong>下图提供ADC相关计算公式：</strong></p><img src=" ../../../../images/8051_ell_lib/doc/ADC.png" style="zoom:75%;" /><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-ADC初始化函数"><a href="#1-ADC初始化函数" class="headerlink" title="1. ADC初始化函数"></a>1. ADC初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>ADC_Init</strong>(const ADC_InitType *ADCx)</td><td align="center">ADC初始化</td></tr></tbody></table><br><h5 id="ADC-InitType-结构体说明"><a href="#ADC-InitType-结构体说明" class="headerlink" title="ADC_InitType 结构体说明"></a>ADC_InitType 结构体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct &#123;    FUNSTATE Power; &#x2F;* ADC电源控制位 *&#x2F;ADCRoad_Type Road; &#x2F;* ADC通道选择 *&#x2F;    uint8_t Speed;   &#x2F;* ADC转换速度（工作时钟频率）最大值为0x0F *&#x2F;    ADCAlign_Type Align;  &#x2F;* ADC数据格式对齐方式 *&#x2F;FUNSTATE run;   &#x2F;* ADC转换运行控制位 *&#x2F;&#125;   ADC_InitType;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="ADC-通道-宏定义说明（建议对照数据手册查看）"><a href="#ADC-通道-宏定义说明（建议对照数据手册查看）" class="headerlink" title="ADC_通道 宏定义说明（建议对照数据手册查看）"></a>ADC_通道 宏定义说明（建议对照数据手册查看）</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define    ADC_Road_REV    0x0F   &#x2F;&#x2F;Test the internal refv voltage&#x2F;* STC8Ax *&#x2F;#define    ADC_Road_P10_8Ax    0x00#define    ADC_Road_P11_8Ax    0x01#define    ADC_Road_P12_8Ax    0x02#define    ADC_Road_P13_8Ax    0x03#define    ADC_Road_P14_8Ax    0x04#define    ADC_Road_P15_8Ax    0x05#define    ADC_Road_P16_8Ax    0x06#define    ADC_Road_P17_8Ax    0x07#define    ADC_Road_P00_8Ax    0x08#define    ADC_Road_P01_8Ax    0x09#define    ADC_Road_P02_8Ax    0x0A#define    ADC_Road_P03_8Ax    0x0B#define    ADC_Road_P04_8Ax    0x0C#define    ADC_Road_P05_8Ax    0x0D#define    ADC_Road_P06_8Ax    0x0E&#x2F;* STC8G1K08A 8Pin *&#x2F;#define    ADC_Road_P30_8G1K08A    0x00#define    ADC_Road_P31_8G1K08A    0x01#define    ADC_Road_P32_8G1K08A    0x02#define    ADC_Road_P33_8G1K08A    0x03        #define    ADC_Road_P54_8G1K08A    0x04#define    ADC_Road_P55_8G1K08A    0x05&#x2F;* STC8G1K08 16Pin and 20Pin &#x2F; STC8G1K08T 20Pin *&#x2F;#define    ADC_Road_P10_8G1K08_T    0x00#define    ADC_Road_P11_8G1K08_T    0x01#define    ADC_Road_P12_8G1K08_T    0x02#define    ADC_Road_P13_8G1K08_T    0x03#define    ADC_Road_P14_8G1K08_T    0x04#define    ADC_Road_P15_8G1K08_T    0x05#define    ADC_Road_P16_8G1K08_T    0x06#define    ADC_Road_P17_8G1K08_T    0x07#define    ADC_Road_P30_8G1K08_T    0x08#define    ADC_Road_P31_8G1K08_T    0x09#define    ADC_Road_P32_8G1K08_T    0x0A#define    ADC_Road_P33_8G1K08_T    0x0B#define    ADC_Road_P34_8G1K08_T    0x0C#define    ADC_Road_P35_8G1K08_T    0x0D#define    ADC_Road_P36_8G1K08_T    0x0E&#x2F;* STC8G2K64S4 16Pin &#x2F; STC8G2K64S2 *&#x2F;#define    ADC_Road_P10_8G2K64S2_S4    0x00#define    ADC_Road_P11_8G2K64S2_S4    0x01#define    ADC_Road_P12_8G2K64S2_S4    0x02#define    ADC_Road_P13_8G2K64S2_S4    0x03#define    ADC_Road_P14_8G2K64S2_S4    0x04#define    ADC_Road_P15_8G2K64S2_S4    0x05#define    ADC_Road_P16_8G2K64S2_S4    0x06#define    ADC_Road_P17_8G2K64S2_S4    0x07#define    ADC_Road_P00_8G2K64S2_S4    0x08#define    ADC_Road_P01_8G2K64S2_S4    0x09#define    ADC_Road_P02_8G2K64S2_S4    0x0A#define    ADC_Road_P03_8G2K64S2_S4    0x0B#define    ADC_Road_P04_8G2K64S2_S4    0x0C#define    ADC_Road_P05_8G2K64S2_S4    0x0D#define    ADC_Road_P06_8G2K64S2_S4    0x0E   &#x2F;* STC8H1K28 *&#x2F;#define    ADC_Road_P10_8H1K28    0x00#define    ADC_Road_P11_8H1K28    0x01#define    ADC_Road_P12_8H1K28    0x02#define    ADC_Road_P13_8H1K28    0x03#define    ADC_Road_P14_8H1K28    0x04#define    ADC_Road_P15_8H1K28    0x05#define    ADC_Road_P16_8H1K28    0x06#define    ADC_Road_P17_8H1K28    0x07#define    ADC_Road_P00_8H1K28    0x08#define    ADC_Road_P01_8H1K28    0x09#define    ADC_Road_P02_8H1K28    0x0A#define    ADC_Road_P03_8H1K28    0x0B&#x2F;* STC8H1K08 *&#x2F;#define    ADC_Road_P10_8H1K08    0x00#define    ADC_Road_P11_8H1K08    0x01#define    ADC_Road_P30_8H1K08    0x08#define    ADC_Road_P31_8H1K08    0x09#define    ADC_Road_P32_8H1K08    0x0A#define    ADC_Road_P33_8H1K08    0x0B#define    ADC_Road_P34_8H1K08    0x0C#define    ADC_Road_P35_8H1K08    0x0D#define    ADC_Road_P36_8H1K08    0x0E&#x2F;* STC8H3K64S2 &#x2F; STC8H3K64S4 *&#x2F;#define    ADC_Road_P10_8H3K64S2_S4    0x00#define    ADC_Road_P11_8H3K64S2_S4    0x01#define    ADC_Road_P12_8H3K64S2_S4    0x02#define    ADC_Road_P16_8H3K64S2_S4    0x06#define    ADC_Road_P17_8H3K64S2_S4    0x07#define    ADC_Road_P00_8H3K64S2_S4    0x08#define    ADC_Road_P01_8H3K64S2_S4    0x09#define    ADC_Road_P02_8H3K64S2_S4    0x0A#define    ADC_Road_P03_8H3K64S2_S4    0x0B#define    ADC_Road_P04_8H3K64S2_S4    0x0C#define    ADC_Road_P05_8H3K64S2_S4    0x0D#define    ADC_Road_P06_8H3K64S2_S4    0x0E&#x2F;* STC8H8K64U &#x2F; STC8H2K64T *&#x2F;#define    ADC_Road_P10_8H8K64U_2K64T    0x00#define    ADC_Road_P11_8H8K64U_2K64T    0x01#define    ADC_Road_P54_8H8K64U_2K64T    0x02#define    ADC_Road_P13_8H8K64U_2K64T    0x03#define    ADC_Road_P14_8H8K64U_2K64T    0x04#define    ADC_Road_P15_8H8K64U_2K64T    0x05#define    ADC_Road_P16_8H8K64U_2K64T    0x06#define    ADC_Road_P17_8H8K64U_2K64T    0x07#define    ADC_Road_P00_8H8K64U_2K64T    0x08#define    ADC_Road_P01_8H8K64U_2K64T    0x09#define    ADC_Road_P02_8H8K64U_2K64T    0x0A#define    ADC_Road_P03_8H8K64U_2K64T    0x0B#define    ADC_Road_P04_8H8K64U_2K64T    0x0C#define    ADC_Road_P05_8H8K64U_2K64T    0x0D#define    ADC_Road_P06_8H8K64U_2K64T    0x0E<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="ADCAlign-Type-枚举体说明"><a href="#ADCAlign-Type-枚举体说明" class="headerlink" title="ADCAlign_Type 枚举体说明"></a>ADCAlign_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;ADC_Left  &#x3D; 0,  &#x2F;* 数据左对齐，高位四位补零 *&#x2F;    ADC_Right &#x3D; 1,  &#x2F;* 数据右对齐，低位四位补零 *&#x2F;&#125;ADCAlign_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="2-ADC采样函数"><a href="#2-ADC采样函数" class="headerlink" title="2. ADC采样函数"></a>2. ADC采样函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uint16_t <strong>ADC_Get_Sample</strong>(ADCRoad_Type Road, ADCAcc_Type Acc)</td><td align="center">ADC查询采样</td></tr><tr><td align="center">uint16_t <strong>ADC_Get_Sample_interrupt</strong>(ADCRoad_Type Road, ADCAcc_Type Acc)</td><td align="center">ADC中断采样</td></tr></tbody></table><br><h5 id="ADCRoad-Type-枚举体说明"><a href="#ADCRoad-Type-枚举体说明" class="headerlink" title="ADCRoad_Type 枚举体说明"></a>ADCRoad_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;    ADC_Acc_12Bit &#x3D; 0,    &#x2F;* 12位精度 *&#x2F;ADC_Acc_11Bit    ,    &#x2F;* 11位精度 *&#x2F;ADC_Acc_10Bit    ,    &#x2F;* 10位精度 *&#x2F;ADC_Acc_9Bit     ,    &#x2F;*  9位精度 *&#x2F;ADC_Acc_8Bit          &#x2F;*  8位精度 *&#x2F;&#125;ADCAcc_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="3-ADC中断初始化函数"><a href="#3-ADC中断初始化函数" class="headerlink" title="3. ADC中断初始化函数"></a>3. ADC中断初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>NVIC_ADC_Init</strong>(NVICPri_Type Priority,FUNSTATE State)</td><td align="center">ADC中断初始化</td></tr></tbody></table><br><h4 id="4-ADC中断服务函数"><a href="#4-ADC中断服务函数" class="headerlink" title="4. ADC中断服务函数"></a>4. ADC中断服务函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void <strong>ADC_ISRQ_Handler</strong>(void)</td><td align="center">ADC中断服务函数</td></tr></tbody></table><br><h4 id="5-ADC中断-采样标志位处理函数"><a href="#5-ADC中断-采样标志位处理函数" class="headerlink" title="5. ADC中断/采样标志位处理函数"></a>5. ADC中断/采样标志位处理函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>ADC_GET_FLAG</strong>()</td><td align="center">ADC获得标志位</td></tr><tr><td align="center"><strong>ADC_CLEAR_FLAG</strong>()</td><td align="center">ADC清理标志位</td></tr></tbody></table><p><strong>说明：</strong>如果在中断服务函数里面调用 <strong>ADC_Get_SampleADC</strong> 采样函数，则不需要处理中断标志，直接调用即可。</p><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><h4 id="1-初始化ADC"><a href="#1-初始化ADC" class="headerlink" title="1.初始化ADC"></a>1.初始化ADC</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">void STC8x_ADC_Config(void)&#123;ADC_InitType ADC_InitStruct&#x3D;&#123;0&#125;; &#x2F;* 定义ADC初始化结构体变量 *&#x2F;GPIO_MODE_IN_FLOATING(GPIO_P1,Pin_3);  &#x2F;* 对选择的通道，设置成浮空输入模式 *&#x2F;ADC_InitStruct.Power &#x3D; ENABLE;  &#x2F;* 开启ADC电源 *&#x2F;ADC_InitStruct.Road &#x3D; ADC_Road_P13; &#x2F;* 选择P1.3作为ADC通道 *&#x2F;ADC_InitStruct.Speed &#x3D; 0x0F;  &#x2F;* ADC转换速度（最慢，但是更精准） *&#x2F;ADC_InitStruct.Align &#x3D; ADC_Right; &#x2F;* 数据格式右对齐 *&#x2F;ADC_InitStruct.run &#x3D; ENABLE;  &#x2F;* 开启ADC转换 *&#x2F;ADC_Init(&amp;ADC_InitStruct);  &#x2F;* 传入ADC初始化结构体地址， 完成初始化 *&#x2F;NVIC_ADC_Init(NVIC_PR1,ENABLE); &#x2F;* 开启ADC中断，查询法不需要开启中断 *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-ADC采样（中断法）"><a href="#2-ADC采样（中断法）" class="headerlink" title="2. ADC采样（中断法）"></a>2. ADC采样（中断法）</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">uint16_t ADC_ dat; &#x2F;* 存放ADC采样转换的结果 *&#x2F;void ADC_ISRQ_Handler(void)&#123;    &#x2F;* 获取ADC采样结果，无需清理标志位 *&#x2F;  ADC_ dat &#x3D; ADC_Get_Sample_interrupt(ADC_Road_P13,ADC_Acc_12Bit);     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-ADC采样（查询法）"><a href="#3-ADC采样（查询法）" class="headerlink" title="3. ADC采样（查询法）"></a>3. ADC采样（查询法）</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;8051_ELL_Lib.h&quot;int main(void)&#123;    uint16_t ADC_ dat;    STC8x_ADC_Config();    for(;;)    &#123;        ADC_Get_Sample(ADC_Road_P13,ADC_Acc_12Bit);&#x2F;&#x2F;第一次结果不要，舍弃掉        ADC_ dat &#x3D; ADC_Get_Sample(ADC_Road_P13,ADC_Acc_12Bit);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-片内外设篇-看门狗</title>
      <link href="2021/03/16/8051ell-ku-pian-nei-wai-she-pian-kan-men-gou/"/>
      <url>2021/03/16/8051ell-ku-pian-nei-wai-she-pian-kan-men-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>看门狗是一个非常重要的外设，在提高系统的稳定性方面有很好的作用。STC8系列引进了该功能，属于热启动中的硬件复位。</p><p>在开启看门狗以后，MCU/CPU需要在规定时间内进行“喂狗”，否则系统将会强制复位，从头开始执行用户程序。</p><p>STC8的看门狗启动有两种方式，分别为软件启动和硬件启动。软件启动可使用库函数，硬件启动需要使用STC-ISP助手，在下载时勾选<strong>上电复位时由硬件自动启动看门狗</strong>。</p><p>看门狗溢出时间的计算，可参照STC8A技术手册系统复位章节。</p><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-看门狗初始化函数"><a href="#1-看门狗初始化函数" class="headerlink" title="1. 看门狗初始化函数"></a>1. 看门狗初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>WDT_Init</strong>(uint8_t CLKDiv,FUNSTATE State)</td><td align="center">看门狗初始化</td></tr></tbody></table><br><h5 id="分频系数-宏定义说明"><a href="#分频系数-宏定义说明" class="headerlink" title="分频系数 宏定义说明"></a>分频系数 宏定义说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define      WDTCLK_DIV2    0x00  &#x2F;&#x2F;2分频#define      WDTCLK_DIV4    0x01  &#x2F;&#x2F;4分频#define      WDTCLK_DIV8    0x02  &#x2F;&#x2F;8分频#define     WDTCLK_DIV16    0x03  &#x2F;&#x2F;16分配#define     WDTCLK_DIV32    0x04  &#x2F;&#x2F;32分配#define     WDTCLK_DIV64    0x05  &#x2F;&#x2F;64分配#define    WDTCLK_DIV128    0x06  &#x2F;&#x2F;128分配#define    WDTCLK_DIV256    0x07  &#x2F;&#x2F;256分配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="2-看门狗操作函数"><a href="#2-看门狗操作函数" class="headerlink" title="2. 看门狗操作函数"></a>2. 看门狗操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>WDT_FEED</strong>()</td><td align="center">看门狗”喂狗“（宏函数）</td></tr><tr><td align="center">uint32 <strong>Get_WDT_Time</strong>(void)</td><td align="center">获取看门狗”喂狗“时间</td></tr></tbody></table><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;8051_ELL_Lib.h&quot;int main(void)&#123;    WDT_Init(WDTCLK_DIV16,ENABLE); &#x2F;* 16分频 使能看门狗 *&#x2F;    for(;;)    &#123;        WDT_FEED(); &#x2F;* 看门狗喂狗 *&#x2F;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-片内外设篇-比较器</title>
      <link href="2021/03/16/8051ell-ku-pian-nei-wai-she-pian-bi-jiao-qi/"/>
      <url>2021/03/16/8051ell-ku-pian-nei-wai-she-pian-bi-jiao-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>STC8系列MCU集成了一个比较器，可以用于电压比较、掉电检查以及电量检测等功能。</p><p>比较器有两级滤波：模拟滤波和数字滤波。模拟滤波可以过滤掉比较输入信号中的毛刺信号，数字滤波可以等待输入信号稳定以后再进行比较，比较结果可以通过寄存器获得，也可以直接输出到IO口。输出到IO口可用作外部事件的触发信号和反馈信号，扩大了比较器的应用范围。</p><p>比较器可以联动ADC的通道，来灵活扩展IO，通过分时的手段，可以实现比较器复用的功能，但是要注意的是，不同的型号ADC的通道引脚有所不同，不过ELL库已经适配了大部分，但是由于数量较多，为防止遗漏和错误，谨慎起见，还请开发者对照官方数据手操作。</p><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-比较器初始化函数"><a href="#1-比较器初始化函数" class="headerlink" title="1. 比较器初始化函数"></a>1. 比较器初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>COMP_Init</strong>(const COMP_InitType *COMPx)</td><td align="center">比较器初始化</td></tr></tbody></table><br><h4 id="2-比较器输出IO口切换函数"><a href="#2-比较器输出IO口切换函数" class="headerlink" title="2. 比较器输出IO口切换函数"></a>2. 比较器输出IO口切换函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>GPIO_COMP_SWPort</strong>(GPIOSWPort_Type Port)</td><td align="center">比较器输出IO口切换</td></tr></tbody></table><br><h4 id="3-比较器中断初始化函数"><a href="#3-比较器中断初始化函数" class="headerlink" title="3. 比较器中断初始化函数"></a>3. 比较器中断初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>NVIC_COMP_Init</strong>(NVICPri_Type priority,COMPTri_Type triMode)</td><td align="center">比较器中断初始化</td></tr><tr><td align="center">FSCSTATE <strong>NVIC_COMP_CTRL</strong>(run)</td><td align="center">比较器中断控制</td></tr></tbody></table><br><h5 id="COMP-InitType-结构体说明"><a href="#COMP-InitType-结构体说明" class="headerlink" title="COMP_InitType 结构体说明"></a>COMP_InitType 结构体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;  COMP_Tri_Null    &#x3D; 0x00,  &#x2F;&#x2F;不触发  COMP_Tri_Falling &#x3D; 0x10,  &#x2F;&#x2F;下降沿触发  COMP_Tri_Rising  &#x3D; 0x20,  &#x2F;&#x2F;上升沿触发  COMP_Tri_Edge    &#x3D; 0x30   &#x2F;&#x2F;边沿触发&#125; COMPTri_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="3-比较器中断服务函数"><a href="#3-比较器中断服务函数" class="headerlink" title="3. 比较器中断服务函数"></a>3. 比较器中断服务函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void <strong>COMP_ISRQ_Handler</strong>(void)</td><td align="center">比较器中断服务函数</td></tr></tbody></table><br><h4 id="4-比较器中断操作函数"><a href="#4-比较器中断操作函数" class="headerlink" title="4. 比较器中断操作函数"></a>4. 比较器中断操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>NVIC_COMP_CTRL</strong>(run)</td><td align="center">比较器中断控制</td></tr><tr><td align="center"><strong>COMP_GET_FLAG</strong>()</td><td align="center">比较器获取标志位</td></tr><tr><td align="center"><strong>COMP_CLEAR_FLAG</strong>()</td><td align="center">比较器清理标志位</td></tr><tr><td align="center"><strong>COMP_GET_RES</strong>()</td><td align="center">比较器获取结果</td></tr><tr><td align="center"><br></td><td align="center"></td></tr></tbody></table><h5 id="COMP-InitType-结构体说明-1"><a href="#COMP-InitType-结构体说明-1" class="headerlink" title="COMP_InitType 结构体说明"></a>COMP_InitType 结构体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct&#123;    uint8_t PEPin;            &#x2F;&#x2F;比较器正极输入选择位    uint8_t NEPin;        &#x2F;&#x2F;比较器负极输入选择位    FUNSTATE AC_FTW;        &#x2F;&#x2F;比较器0.1us模拟滤波 0 DISABLE &#x2F; 1 ENABLE    uint16_t DC_FTW;          &#x2F;&#x2F;比较器数字滤波 0代表关闭 最大0x3F    COMPDIRPut_Type DIRPut; &#x2F;&#x2F;比较器输出方向选择    FUNSTATE Output;        &#x2F;&#x2F;比较器输出控制位    FUNSTATE run;           &#x2F;&#x2F;比较器运行控制位&#125;   COMP_InitType;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="正负极输入端口-宏定义说明"><a href="#正负极输入端口-宏定义说明" class="headerlink" title="正负极输入端口 宏定义说明"></a>正负极输入端口 宏定义说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* PEPin *&#x2F;#define  COMP_PE_P37     0xF7&#x2F;* STC8Ax *&#x2F;#define    COMP_PE_P10_8Ax    0x00#define    COMP_PE_P11_8Ax    0x01#define    COMP_PE_P12_8Ax    0x02#define    COMP_PE_P13_8Ax    0x03#define    COMP_PE_P14_8Ax    0x04#define    COMP_PE_P15_8Ax    0x05#define    COMP_PE_P16_8Ax    0x06#define    COMP_PE_P17_8Ax    0x07#define    COMP_PE_P00_8Ax    0x08#define    COMP_PE_P01_8Ax    0x09#define    COMP_PE_P02_8Ax    0x0A#define    COMP_PE_P03_8Ax    0x0B#define    COMP_PE_P04_8Ax    0x0C#define    COMP_PE_P05_8Ax    0x0D#define    COMP_PE_P06_8Ax    0x0E&#x2F;* STC8G1K08A 8Pin *&#x2F;#define    COMP_PE_P30_8G1K08A    0x00#define    COMP_PE_P31_8G1K08A    0x01#define    COMP_PE_P32_8G1K08A    0x02#define    COMP_PE_P33_8G1K08A    0x03        #define    COMP_PE_P54_8G1K08A    0x04#define    COMP_PE_P55_8G1K08A    0x05&#x2F;* STC8G1K08 16Pin and 20Pin &#x2F; STC8G1K08T 20Pin *&#x2F;#define    COMP_PE_P10_8G1K08_T    0x00#define    COMP_PE_P11_8G1K08_T    0x01#define    COMP_PE_P12_8G1K08_T    0x02#define    COMP_PE_P13_8G1K08_T    0x03#define    COMP_PE_P14_8G1K08_T    0x04#define    COMP_PE_P15_8G1K08_T    0x05#define    COMP_PE_P16_8G1K08_T    0x06#define    COMP_PE_P17_8G1K08_T    0x07#define    COMP_PE_P30_8G1K08_T    0x08#define    COMP_PE_P31_8G1K08_T    0x09#define    COMP_PE_P32_8G1K08_T    0x0A#define    COMP_PE_P33_8G1K08_T    0x0B#define    COMP_PE_P34_8G1K08_T    0x0C#define    COMP_PE_P35_8G1K08_T    0x0D#define    COMP_PE_P36_8G1K08_T    0x0E&#x2F;* STC8G2K64S4 16Pin &#x2F; STC8G2K64S2 *&#x2F;#define    COMP_PE_P10_8G2K64S2_S4    0x00#define    COMP_PE_P11_8G2K64S2_S4    0x01#define    COMP_PE_P12_8G2K64S2_S4    0x02#define    COMP_PE_P13_8G2K64S2_S4    0x03#define    COMP_PE_P14_8G2K64S2_S4    0x04#define    COMP_PE_P15_8G2K64S2_S4    0x05#define    COMP_PE_P16_8G2K64S2_S4    0x06#define    COMP_PE_P17_8G2K64S2_S4    0x07#define    COMP_PE_P00_8G2K64S2_S4    0x08#define    COMP_PE_P01_8G2K64S2_S4    0x09#define    COMP_PE_P02_8G2K64S2_S4    0x0A#define    COMP_PE_P03_8G2K64S2_S4    0x0B#define    COMP_PE_P04_8G2K64S2_S4    0x0C#define    COMP_PE_P05_8G2K64S2_S4    0x0D#define    COMP_PE_P06_8G2K64S2_S4    0x0E   &#x2F;* STC8H1K28 *&#x2F;#define    COMP_PE_P10_8H1K28    0x00#define    COMP_PE_P11_8H1K28    0x01#define    COMP_PE_P12_8H1K28    0x02#define    COMP_PE_P13_8H1K28    0x03#define    COMP_PE_P14_8H1K28    0x04#define    COMP_PE_P15_8H1K28    0x05#define    COMP_PE_P16_8H1K28    0x06#define    COMP_PE_P17_8H1K28    0x07#define    COMP_PE_P00_8H1K28    0x08#define    COMP_PE_P01_8H1K28    0x09#define    COMP_PE_P02_8H1K28    0x0A#define    COMP_PE_P03_8H1K28    0x0B&#x2F;* STC8H1K08 *&#x2F;#define    COMP_PE_P10_8H1K08    0x00#define    COMP_PE_P11_8H1K08    0x01#define    COMP_PE_P30_8H1K08    0x08#define    COMP_PE_P31_8H1K08    0x09#define    COMP_PE_P32_8H1K08    0x0A#define    COMP_PE_P33_8H1K08    0x0B#define    COMP_PE_P34_8H1K08    0x0C#define    COMP_PE_P35_8H1K08    0x0D#define    COMP_PE_P36_8H1K08    0x0E&#x2F;* STC8H3K64S2 &#x2F; STC8H3K64S4 *&#x2F;#define    COMP_PE_P10_8H3K64S2_S4    0x00#define    COMP_PE_P11_8H3K64S2_S4    0x01#define    COMP_PE_P12_8H3K64S2_S4    0x02#define    COMP_PE_P16_8H3K64S2_S4    0x06#define    COMP_PE_P17_8H3K64S2_S4    0x07#define    COMP_PE_P00_8H3K64S2_S4    0x08#define    COMP_PE_P01_8H3K64S2_S4    0x09#define    COMP_PE_P02_8H3K64S2_S4    0x0A#define    COMP_PE_P03_8H3K64S2_S4    0x0B#define    COMP_PE_P04_8H3K64S2_S4    0x0C#define    COMP_PE_P05_8H3K64S2_S4    0x0D#define    COMP_PE_P06_8H3K64S2_S4    0x0E&#x2F;* STC8H8K64U &#x2F; STC8H2K64T *&#x2F;#define    COMP_PE_P10_8H8K64U_2K64T    0x00#define    COMP_PE_P11_8H8K64U_2K64T    0x01#define    COMP_PE_P54_8H8K64U_2K64T    0x02#define    COMP_PE_P13_8H8K64U_2K64T    0x03#define    COMP_PE_P14_8H8K64U_2K64T    0x04#define    COMP_PE_P15_8H8K64U_2K64T    0x05#define    COMP_PE_P16_8H8K64U_2K64T    0x06#define    COMP_PE_P17_8H8K64U_2K64T    0x07#define    COMP_PE_P00_8H8K64U_2K64T    0x08#define    COMP_PE_P01_8H8K64U_2K64T    0x09#define    COMP_PE_P02_8H8K64U_2K64T    0x0A#define    COMP_PE_P03_8H8K64U_2K64T    0x0B#define    COMP_PE_P04_8H8K64U_2K64T    0x0C#define    COMP_PE_P05_8H8K64U_2K64T    0x0D#define    COMP_PE_P06_8H8K64U_2K64T    0x0E&#x2F;* NEPin *&#x2F;#define  COMP_NE_P36     0x10&#x2F;* NEPin and PEPin :Test the internal 1.344v refv voltage.*&#x2F;#define COMP_IN_REV     0x0F<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="COMPDIRPut-Type结构体说明"><a href="#COMPDIRPut-Type结构体说明" class="headerlink" title="COMPDIRPut_Type结构体说明"></a>COMPDIRPut_Type结构体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;    COMP_DIR_Forward &#x3D; 0,  &#x2F;&#x2F;正向输出    COMP_DIR_Reverse       &#x2F;&#x2F;反向输出&#125;   COMPDIRPut_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;8051_ELL_Lib.h&quot;void STC8x_COMP_Config(void)&#123;COMP_InitType COMP_InitStruct&#x3D;&#123;0&#125;;GPIO_MODE_IN_FLOATING(GPIO_P3,Pin_7);   &#x2F;&#x2F;浮空输入COMP_InitStruct.PEPin &#x3D; COMP_PE_P37;    &#x2F;&#x2F;正极选择P37COMP_InitStruct.NEPin &#x3D; COMP_IN_REV;    &#x2F;&#x2F;负极选择内部参考电压COMP_InitStruct.AC_FTW &#x3D; ENABLE;       &#x2F;&#x2F;使能模拟滤波COMP_InitStruct.DC_FTW &#x3D; 0x08;        &#x2F;&#x2F;开启数字滤波，滤波级别0x08COMP_InitStruct.DIRPut &#x3D; COMP_DIR_Forward;  &#x2F;&#x2F; 正向输出COMP_InitStruct.Output &#x3D; ENABLE;     &#x2F;&#x2F;输出比较结果COMP_InitStruct.run &#x3D; ENABLE;       &#x2F;&#x2F;使能运行COMP_Init(&amp;COMP_InitStruct);NVIC_COMP_Init(NVIC_PR0,COMP_Tri_Edge);  &#x2F;&#x2F;开启中断&#125;void COMP_ISRQ_Handler (void) &#123;    uint8_t res;    if(COMP_GET_FLAG())    &#123;        COMP_CLEAR_FLAG();        res &#x3D; COMP_GET_RES();    &#125;&#125;int main(void)&#123;    STC8x_COMP_Config();    for(;;)&#123;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-代码烧录</title>
      <link href="2021/03/16/8051ell-ku-dai-ma-shao-lu/"/>
      <url>2021/03/16/8051ell-ku-dai-ma-shao-lu/</url>
      
        <content type="html"><![CDATA[<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>本章节介绍固件库的烧录流程,使用的工具是stc-isp助手，对整个STC8系列都适用。</p><h2 id="具体流程-手动烧录"><a href="#具体流程-手动烧录" class="headerlink" title="具体流程-手动烧录"></a>具体流程-手动烧录</h2><p>点击<strong>Build</strong>图标编译，或者按下快捷键F7；</p><img src=" ../../../../images/8051_ell_lib/doc/Burn1.png" style="zoom:75%;" /><p>打开stc-isp助手，按照图示设置</p><img src=" ../../../../images/8051_ell_lib/doc/Burn2.png" style="zoom:75%;" /><ul><li><p>标号1：选择MCU型号（也可通过左下角的 <strong>检测MCU选项</strong> 来智能选择）</p></li><li><p>标号2： 选择工程文件（.hex格式）</p></li><li><p>标号3：选择工作频率（如果是接外部晶振，则不需要）</p></li></ul><p>最后选择下载/编程，即可完成下载。</p><h2 id="补充-自动下载烧录"><a href="#补充-自动下载烧录" class="headerlink" title="补充-自动下载烧录"></a>补充-自动下载烧录</h2><p>首先在工程里初始化串口1</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void STC8x_UART_Config(void)&#123;UART_InitType UART_InitStruct&#x3D;&#123;0&#125;;&#x2F;&#x2F; 定义串口初始化结构体&#x2F;* UART1 TXD *&#x2F;GPIO_MODE_OUT_PP(GPIO_P3,Pin_1); &#x2F;&#x2F;P31口设置为推挽输出&#x2F;* UART1 RXD *&#x2F;GPIO_MODEIN_FLOATING(GPIO_P3,Pin_0); &#x2F;&#x2F;P30口设置为浮空输入    UART_InitStruct.Mode &#x3D; UART_8bit_BRTx;  &#x2F;&#x2F; 工作模式： 8位波特率可变模式UART_InitStruct.BRTGen &#x3D; UART_BRT_TIM1; &#x2F;&#x2F; 波特率发生器：定时器1UART_InitStruct.BRTMode &#x3D; UART_BRT_1T;  &#x2F;&#x2F; 波特率发生器模式：1T模式UART_InitStruct.BaudRate &#x3D; 115200;  &#x2F;&#x2F; 波特率值：115200UART_InitStruct.RxEnable &#x3D; ENABLE;  &#x2F;&#x2F; 接收使能控制位：开启接收UART1_Init(&amp;UART_InitStruct);   &#x2F;&#x2F;串口1初始化函数，传入结构体地址NVIC_UART1_Init(NVIC_PR0,ENABLE); &#x2F;&#x2F;串口1中断初始化函数，0优先级，开启中断。&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后在串口中断服务函数里填写如下代码</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void UART1_ISRQ_Handler(void)&#123;if(UART1_GET_RX_FLAG())&#123;UART1_CLEAR_RX_FLAG();        Auto_RST_download();  &#x2F;&#x2F;这个函数实现了代码下载的功能&#125;else if(UART1_GET_TX_FLAG())&#123;UART1_CLEAR_TX_FLAG();        UART1_CLEAR_BUSY_FLAG();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后设置STC-ISP助手</p><img src=" ../../../../images/8051_ell_lib/doc/Burn3.png" style="zoom:75%;" /><ul><li><p>选择【收到命令后复位到ISP监控区】</p></li><li><p>波特率选择115200 检验位无 停止位1位</p></li><li><p>勾选Hex模式 输入自定义命令</p></li><li><p>勾选每次下载前都先发送自定义命令</p></li><li><p>勾选当目标文件变化时自动装载并发送自定义下载命令</p></li><li><p>勾选当目标文件变化时自动装载并发送下载命令</p></li></ul><p>自定义命令(复制到STC-ISP自定义命令输入框内)：</p><pre class="line-numbers language-none"><code class="language-none">7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-片内外设篇-复位功能</title>
      <link href="2021/03/16/8051ell-ku-pian-nei-wai-she-pian-fu-wei-gong-neng/"/>
      <url>2021/03/16/8051ell-ku-pian-nei-wai-she-pian-fu-wei-gong-neng/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>STC8系列MCU的复位，分为软件复位和硬件复位两种。</p><p>硬件复位主要包括：上电复位、低压复位、复位脚复位、看门狗复位。硬件复位时，所有寄存器的值会复位到初始值，系统会复位到初始值，系统会重新读取所有的硬件选项。</p><p>软件复位主要包括：写IAP_CONTR的<strong>SWRST</strong>所触发的复位。软件复位时，除与时钟相关的寄存器保持不变外，其余的所有寄存器都会复位到初始值。软件复位不会重新读取所有硬件选项。</p><p>同时我们在本模块中增加了串口自动下载功能，原理就是利用了软复位。</p><blockquote><p><strong>低压复位</strong> 提供4级低压检测电压：2.V、2.4V、2.7V、3.0V，复位引脚为P5.4。</p></blockquote><blockquote><p><strong>复位脚复位</strong> 复位脚为P5.4，高电平复位。要注意的是，MCU出厂时，<strong>P5.4默认作为普通I/O口</strong>，要自己手动设置为复位脚。</p></blockquote><blockquote><p><strong>看门狗复位</strong> 本功能在看门狗章节详细介绍。</p></blockquote><blockquote><p><strong>软件复位</strong> 控制寄存器IAP_CONTR的SWRST，实现软件复位，可选择复位到用户程序区或者系统ISP区。</p></blockquote><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-低压复位初始化函数"><a href="#1-低压复位初始化函数" class="headerlink" title="1. 低压复位初始化函数"></a>1. 低压复位初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>LVD_RST_Init</strong>(LVDRstDiv_Type lvDiv,FUNSTATE run)</td><td align="center">低压复位初始化</td></tr></tbody></table><br><h5 id="RSTPinMode-Type-枚举体说明"><a href="#RSTPinMode-Type-枚举体说明" class="headerlink" title="RSTPinMode_Type 枚举体说明"></a>RSTPinMode_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;  LVD_RST_2_2V,  &#x2F;* 低压检测门槛 2.2V *&#x2F;  LVD_RST_2_4V,  &#x2F;* 低压检测门槛 2.4V *&#x2F;  LVD_RST_2_7V,  &#x2F;* 低压检测门槛 2.7V *&#x2F;  LVD_RST_3_0V   &#x2F;* 低压检测门槛 3.0V *&#x2F;&#125; LVDRstDiv_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="2-低压复位中断服务函数"><a href="#2-低压复位中断服务函数" class="headerlink" title="2. 低压复位中断服务函数"></a>2. 低压复位中断服务函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>LVD_ISRQ_Handler</strong>(void)</td><td align="center">低压复位中断服务函数</td></tr></tbody></table><br><h4 id="3-低压复位中断操作函数"><a href="#3-低压复位中断操作函数" class="headerlink" title="3. 低压复位中断操作函数"></a>3. 低压复位中断操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>LVD_GET_FLAG</strong>()</td><td align="center">低压复位获取中断标志位（宏函数）</td></tr><tr><td align="center"><strong>LVD_CLEAR_FLAG</strong>()</td><td align="center">低压复位清除中断标志位（宏函数）</td></tr></tbody></table><br><h4 id="4-复位脚复位函数"><a href="#4-复位脚复位函数" class="headerlink" title="4. 复位脚复位函数"></a>4. 复位脚复位函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>RST_P54_ENABLE</strong>()</td><td align="center">使能P5.4作为复位脚（宏函数）</td></tr><tr><td align="center"><strong>RST_P54_DISABLE</strong>()</td><td align="center">取消P5.4作为复位脚（宏函数）</td></tr></tbody></table><br><h4 id="5-软件复位控制函数"><a href="#5-软件复位控制函数" class="headerlink" title="5. 软件复位控制函数"></a>5. 软件复位控制函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>SFW_RST_Ctrl</strong>(RSTChoice_Type choice, FUNSTATE run)</td><td align="center">软件复位</td></tr><tr><td align="center">void <strong>Auto_RST_download</strong>(void)</td><td align="center">自动下载功能</td></tr></tbody></table><br><h5 id="RSTChoice-Type-枚举体说明"><a href="#RSTChoice-Type-枚举体说明" class="headerlink" title="RSTChoice_Type 枚举体说明"></a>RSTChoice_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;  RST_USER_ datA_KEEP ,&#x2F;* 软件复位以后, 从用户代码区开始执行代码，RAM数据保存 *&#x2F;  RST_USER_ datA_CLEAN &#x2F;* 软件复位以后, 从系统ISP区开始执行代码，RAM数据清空 *&#x2F;&#125; RSTChoice_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><h5 id="低压复位操作"><a href="#低压复位操作" class="headerlink" title="低压复位操作"></a>低压复位操作</h5><p>```C</p><p>#include “8051_ELL_Lib.h”</p><p>int main(void)<br>{<br>    delay_init();<br>    GPIO_MODE_OUT_PP(GPIO_P1,Pin0);<br>    LVD_RST_Init(LVD_RST_3_0V,ENABLE); //检测到3V电压，进行复位。</p><pre><code>for(;;)&#123;    P10 = !P10;  //每500ms翻转一次，当MCU复位以后，重新开始    delay_ms(500);&#125;</code></pre><p>}<br>```C</p>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-片内外设篇-中断管理</title>
      <link href="2021/03/16/8051ell-ku-pian-nei-wai-she-pian-zhong-duan-guan-li/"/>
      <url>2021/03/16/8051ell-ku-pian-nei-wai-she-pian-zhong-duan-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>STC8系列MCU的中断系统支持4级中断优先级，中断源常见的有（基本型号都有的）：外部中断0<del>3中断、定时器0</del>3中断、串口1~4中断、ADC中断、PWM中断、PWM异常检测中断、COMP中断、PCA中断、低压检测中断、SPI中断、IIC中断。多数中断的优先级，可由软件来设置。</p><p>中断优先级的数字越大，则优先级越高。</p><p>ELL库对MCU进行了中断管理的集中封装，每一个外设的中断处理，都会放在中断管理的模块文件里，但是为了方便讲解，相关外设的中断处理，我们会放到对应的外设中讲解，这里只把总中断的开关控制和外部中断放到一起讲。</p><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-总中断操作函数"><a href="#1-总中断操作函数" class="headerlink" title="1.总中断操作函数"></a>1.总中断操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>NVIC_GLOBAL_ENABLE</strong>()</td><td align="center">开启总中断（宏函数）</td></tr><tr><td align="center"><strong>NVIC_GLOBAL_DISABLE</strong>()</td><td align="center">关闭总中断（宏函数）</td></tr></tbody></table><br><h4 id="2-外部中断触发模式选择函数"><a href="#2-外部中断触发模式选择函数" class="headerlink" title="2.外部中断触发模式选择函数"></a>2.外部中断触发模式选择函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>EXTI0_TRIMode_Init</strong>(EXTITri_Type triMode)</td><td align="center">外中断0中断触发模式选择</td></tr><tr><td align="center">FSCSTATE <strong>EXTI1_TRIMode_Init</strong>(EXTITri_Typte triMode)</td><td align="center">外中断1中断触发模式选择</td></tr></tbody></table><br><h4 id="3-外部中断中断初始化函数"><a href="#3-外部中断中断初始化函数" class="headerlink" title="3. 外部中断中断初始化函数"></a>3. 外部中断中断初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>NVIC_EXTI0_Init</strong>(NVICPri_Type Priority,FUNSTATE Run)</td><td align="center">外部中断0中断初始化</td></tr><tr><td align="center">FSCSTATE <strong>NVIC_EXTI1_Init</strong>(NVICPri_Type Priority,FUNSTATE Run)</td><td align="center">外部中断1中断初始化</td></tr><tr><td align="center">FSCSTATE <strong>NVIC_EXTI2_Init</strong>(FUNSTATE Run)</td><td align="center">外部中断2中断初始化</td></tr><tr><td align="center">FSCSTATE <strong>NVIC_EXTI3_Init</strong>(FUNSTATE Run)</td><td align="center">外部中断3中断初始化</td></tr></tbody></table><br><h5 id="NVICPri-Type-枚举体说明"><a href="#NVICPri-Type-枚举体说明" class="headerlink" title="NVICPri_Type 枚举体说明"></a>NVICPri_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;  NVIC_PR0  &#x3D;  0x00,  &#x2F;* 0中断优先级 | *&#x2F;  NVIC_PR1  &#x3D;  0x01,  &#x2F;* 1中断优先级 | *&#x2F;  NVIC_PR2  &#x3D;  0x02,  &#x2F;* 2中断优先级 | *&#x2F;  NVIC_PR3  &#x3D;  0x03   &#x2F;* 3中断优先级 V *&#x2F;&#125; NVICPri_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="4-外部中断中断服务函数"><a href="#4-外部中断中断服务函数" class="headerlink" title="4.外部中断中断服务函数"></a>4.外部中断中断服务函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>EXTI0_ISRQ_Handler</strong>(void)</td><td align="center">外部中断0中断服务函数</td></tr><tr><td align="center"><strong>EXTI1_ISRQ_Handler</strong>(void)</td><td align="center">外部中断1中断服务函数</td></tr><tr><td align="center"><strong>EXTI2_ISRQ_Handler</strong>(void)</td><td align="center">外部中断2中断服务函数</td></tr><tr><td align="center"><strong>EXTI3_ISRQ_Handler</strong>(void)</td><td align="center">外部中断3中断服务函数</td></tr></tbody></table><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><h4 id="1-初始化外部中断"><a href="#1-初始化外部中断" class="headerlink" title="1. 初始化外部中断"></a>1. 初始化外部中断</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;8051_ELL_Lib.h&quot;int main(void)&#123;EXTI0_TRIMode_Init(EXTI_Tri_Falling); &#x2F;* 选择外部中断触发方式 *&#x2F;NVIC_EXTI0_Init(NVIC_PR0,ENABLE); &#x2F;* 开启外部中断0 *&#x2F;    NVIC_GLOBAL_ENABLE(); &#x2F;*开启总中断*&#x2F;        for(;;)    &#123;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-编写中断服务函数"><a href="#2-编写中断服务函数" class="headerlink" title="2. 编写中断服务函数"></a>2. 编写中断服务函数</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">void EXTI0_ISRQ_Handler(void)&#123;  P50 &#x3D; !P50;  &#x2F;* 当P3.2有下降沿信号时，P5.0高低电平翻转 *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-片内外设篇-电源管理</title>
      <link href="2021/03/16/8051ell-ku-pian-nei-wai-she-pian-dian-yuan-guan-li/"/>
      <url>2021/03/16/8051ell-ku-pian-nei-wai-she-pian-dian-yuan-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>STC8系列MCU的系统电源有三种工作方式，分别是正常模式、掉电模式、空闲模式。开发者可以按照需求进行切换，大大降低了使用功耗。</p><blockquote><p><strong>正常模式</strong> 该模式为MCU默认的电源工作模式，功耗一般，有一个上电标志位寄存器，可以指示MCU的电源情况（是否上电）。</p></blockquote><blockquote><p><strong>掉电模式</strong> MCU进入掉电模式后，CPU以及全部外设均停止工作。唤醒后硬件会对做相应的控制位清零操作。</p></blockquote><blockquote><p><strong>空闲模式</strong> MCU进入空闲模式以后，只有CPU停止工作，其他外设依然运行，唤醒后，硬件自动清零。</p></blockquote><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="电源工作模式配置函数"><a href="#电源工作模式配置函数" class="headerlink" title="电源工作模式配置函数"></a>电源工作模式配置函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>POWER_Mode_Ctrl</strong>(POWERMode_Type mode)</td><td align="center">电源工作模式</td></tr><tr><td align="center">uint8_t GET_POWER_STATE(void)</td><td align="center">获取上电状态</td></tr></tbody></table><br><h5 id="POWERMode-Type-枚举体说明"><a href="#POWERMode-Type-枚举体说明" class="headerlink" title="POWERMode_Type 枚举体说明"></a>POWERMode_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;  POWER_Mode_Normal &#x3D; 0x00, &#x2F;* 电源正常模式 *&#x2F;  POWER_Mode_Down   &#x3D; 0x02, &#x2F;* 电源掉电模式 *&#x2F;  POWER_Mode_Idle   &#x3D; 0x03  &#x2F;* 电源空闲模式 *&#x2F;&#125; POWERMode_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><h5 id="选择电源工作模式"><a href="#选择电源工作模式" class="headerlink" title="选择电源工作模式"></a>选择电源工作模式</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;8051_ELL_Lib.h&quot;int main(void)&#123;    EXTI0_TRIMode_Init(EXTI_Tri_Falling); &#x2F;* 选择外部中断触发方式 *&#x2F;NVIC_EXTI0_Init(NVIC_PR0,ENABLE); &#x2F;* 开启外部中断0 *&#x2F;    POWER_Mode_Ctrl(POWER_Mode_Down); &#x2F;* 进入掉电模式 *&#x2F;    NVIC_GLOBAL_ENABLE(); &#x2F;*开启总中断*&#x2F;        for(;;)    &#123;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="通过外部中断唤醒"><a href="#通过外部中断唤醒" class="headerlink" title="通过外部中断唤醒"></a>通过外部中断唤醒</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">void EXTI0_ISRQ_Handler(void)&#123;  P50 &#x3D; !P50;  &#x2F;* 当P3.2有下降沿信号时，P5.0高低电平翻转,同时唤醒MCU *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-片内外设篇-增强型PWM</title>
      <link href="2021/03/14/8051ell-ku-pian-nei-wai-she-pian-zeng-qiang-xing-pwm/"/>
      <url>2021/03/14/8051ell-ku-pian-nei-wai-she-pian-zeng-qiang-xing-pwm/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>STC8A、STC8G的部分型号，集成了一个15位的高精度增强型PWM波形发生器，有8路PWM通道可供使用。可软件调节输出的PWM占空比，通过软件干预，能够实现多路互补/对称/带死区的PWM波形。可以关联比较器和ADC，实现异常检测和实时触发ADC转换功能。</p><br><p><strong>PWM输出频率计算公式：</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">系统时钟做时钟源：    输出频率 &#x3D; 系统工作频率 &#x2F; （系统时钟分频数 * PWM周期）；    定时器2做时钟源：    输出频率 &#x3D; 系统工作频率 &#x2F; PWM周期；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-PCA计数器初始化函数"><a href="#1-PCA计数器初始化函数" class="headerlink" title="1. PCA计数器初始化函数"></a>1. PCA计数器初始化函数</h4><h4 id="1-PWM计数器初始化函数"><a href="#1-PWM计数器初始化函数" class="headerlink" title="1. PWM计数器初始化函数"></a>1. PWM计数器初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>PWM_CNT_Init</strong>(PWMCLKSrc_Type clkSrc,uint16_t value,FUNSTATE run)</td><td align="center">PWM计数器初始化</td></tr></tbody></table><p><strong>value：</strong>计数器预置值，即PWM周期 （  = value * PWM时钟 ）</p><p><strong>run：</strong>计数器运行状态控制位</p><br><h5 id="PWMCLKSrc-Type-枚举体说明"><a href="#PWMCLKSrc-Type-枚举体说明" class="headerlink" title="PWMCLKSrc_Type  枚举体说明"></a>PWMCLKSrc_Type  枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;    PWM_SCLK_DIV_1  &#x3D;  0x00,   &#x2F;&#x2F;系统时钟1分频    PWM_SCLK_DIV_2  &#x3D;  0x01,   &#x2F;&#x2F;系统时钟2分频    PWM_SCLK_DIV_3  &#x3D;  0x02,   &#x2F;&#x2F;系统时钟3分频    PWM_SCLK_DIV_4  &#x3D;  0x03,   &#x2F;&#x2F;系统时钟4分频    PWM_SCLK_DIV_5  &#x3D;  0x04,   &#x2F;&#x2F;系统时钟5分频    PWM_SCLK_DIV_6  &#x3D;  0x05,   &#x2F;&#x2F;系统时钟6分频    PWM_SCLK_DIV_7  &#x3D;  0x06,   &#x2F;&#x2F;系统时钟7分频    PWM_SCLK_DIV_8  &#x3D;  0x07,   &#x2F;&#x2F;系统时钟8分频    PWM_SCLK_DIV_9  &#x3D;  0x08,   &#x2F;&#x2F;系统时钟9分频    PWM_SCLK_DIV_10 &#x3D;  0x09,   &#x2F;&#x2F;系统时钟10分频    PWM_SCLK_DIV_11 &#x3D;  0x0A,   &#x2F;&#x2F;系统时钟11分频    PWM_SCLK_DIV_12 &#x3D;  0x0B,   &#x2F;&#x2F;系统时钟12分频    PWM_SCLK_DIV_13 &#x3D;  0x0C,   &#x2F;&#x2F;系统时钟13分频    PWM_SCLK_DIV_14 &#x3D;  0x0D,   &#x2F;&#x2F;系统时钟14分频    PWM_SCLK_DIV_15 &#x3D;  0x0E,   &#x2F;&#x2F;系统时钟15分频    PWM_SCLK_DIV_16 &#x3D;  0x0F,   &#x2F;&#x2F;系统时钟16分频    PWM_TIMER2_PULSE &#x3D; 0x1F    &#x2F;&#x2F;定时器2溢出脉冲&#125;   PWMCLKSrc_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="2-PWMx通道初始化函数（x-0-7）"><a href="#2-PWMx通道初始化函数（x-0-7）" class="headerlink" title="2. PWMx通道初始化函数（x:0~7）"></a>2. PWMx通道初始化函数（x:0~7）</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>PWMx_Init</strong>(PWMStartLevel_Type level,uint16_t fValue,uint16_t sValue,FUNSTATE run)</td><td align="center">PWM0x:0~7初始化</td></tr></tbody></table><p><strong>level：</strong>初始电平</p><p><strong>fValue：</strong>第一个翻转点，翻转后变为低电平</p><p><strong>sValue：</strong>第二个翻转点，翻转后变为高电平</p><p><strong>run：</strong>计数器运行状态控制位</p><br><h5 id="PWMStartLevel-Type-枚举体说明"><a href="#PWMStartLevel-Type-枚举体说明" class="headerlink" title="PWMStartLevel_Type 枚举体说明"></a>PWMStartLevel_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;    PWM_Start_Low_Level  &#x3D;  0x00,  &#x2F;&#x2F;初始化为低电平    PWM_Start_High_Level &#x3D;  0x01   &#x2F;&#x2F;初始化为高电平&#125;   PWMStartLevel_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="3-PWMx占空比控制函数（x-0-7）"><a href="#3-PWMx占空比控制函数（x-0-7）" class="headerlink" title="3. PWMx占空比控制函数（x:0~7）"></a>3. PWMx占空比控制函数（x:0~7）</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>PWMx_DUTY_CTRL</strong>(fValue,sVfalue)</td><td align="center">PWM0x占空比调节</td></tr></tbody></table><p><strong>fValue：</strong>第一个翻转点，翻转后变为低电平</p><p><strong>sValue：</strong>第二个翻转点，翻转后变为高电平</p><br><h4 id="4-PWM异常检测函数"><a href="#4-PWM异常检测函数" class="headerlink" title="4. PWM异常检测函数"></a>4. PWM异常检测函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>PWM_ABD_Init</strong>(PWMADSMode_Type Mode,PWMABSignal_Type Signal,FUNSTATE Run)</td><td align="center">PWM异常检测</td></tr></tbody></table><br><h5 id="PWMADSMode-Type-枚举体说明"><a href="#PWMADSMode-Type-枚举体说明" class="headerlink" title="PWMADSMode_Type 枚举体说明"></a>PWMADSMode_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;    PWM_ADS_P35  &#x3D; 0x02,  &#x2F;&#x2F;选择P35    PWM_ADS_COMP &#x3D; 0x04   &#x2F;&#x2F;选择比较器&#125;   PWMADSMode_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="PWMABSignal-Type-枚举体说明"><a href="#PWMABSignal-Type-枚举体说明" class="headerlink" title="PWMABSignal_Type 枚举体说明"></a>PWMABSignal_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;    PWM_COMP_Low_To_High &#x3D; 0x00,  &#x2F;&#x2F;比较器结果由低到高为异常信号    PWM_COMP_High_To_Low &#x3D; 0x80,  &#x2F;&#x2F;比较器结果由高到低为异常信号    PWM_P35_Low_To_High  &#x3D; 0x00,  &#x2F;&#x2F;P35输入电平由低到高为异常信号    PWM_P35_High_To_Low  &#x3D; 0x40   &#x2F;&#x2F;P35输入电平由高到低为异常信号&#125;   PWMABSignal_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="5-PWM关联ADC函数"><a href="#5-PWM关联ADC函数" class="headerlink" title="5. PWM关联ADC函数"></a>5. PWM关联ADC函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>PWM_ETADC_Init</strong>(uint16_t value,FUNSTATE run)</td><td align="center">PWM关联ADC</td></tr></tbody></table><p><strong>Value ：</strong>触发ADC自动采样预置值</p><p><strong>run：</strong>运行状态控制位</p><br><h4 id="6-PWM中断初始化函数"><a href="#6-PWM中断初始化函数" class="headerlink" title="6. PWM中断初始化函数"></a>6. PWM中断初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>NVIC_PWM_CNT_Init</strong>(NVICPri_Type Priority,FUNSTATE Run)</td><td align="center">PWM计数器中断初始化</td></tr><tr><td align="center">FSCSTATE <strong>NVIC_PWM_ABD_Init</strong>(NVICPri_Type Priority,FUNSTATE Run)</td><td align="center">PWM关联ADC中断初始化</td></tr><tr><td align="center">FSCSTATE <strong>NVIC_PWMx_Init</strong>(PWMFlip_Type FlipMode)</td><td align="center">PWM通道中断初始化（x：0~7）</td></tr></tbody></table><br><h4 id="7-PWM中断服务函数"><a href="#7-PWM中断服务函数" class="headerlink" title="7. PWM中断服务函数"></a>7. PWM中断服务函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void <strong>PWM_ISRQ_Handler</strong>(void)</td><td align="center">PWM中断服务函数</td></tr><tr><td align="center">void <strong>PWM_ABD_ISRQ_Handler</strong>(void)</td><td align="center">PWM异常检测中断服务函数</td></tr></tbody></table><br><h4 id="8-PWM中断标志位操作函数"><a href="#8-PWM中断标志位操作函数" class="headerlink" title="8. PWM中断标志位操作函数"></a>8. PWM中断标志位操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>PWM_CNT_RTZ_GET_FLAG</strong>()</td><td align="center">PWM获取中断计数器标志位</td></tr><tr><td align="center"><strong>PWM_ABD_GET_FLAG</strong>()</td><td align="center">PWM获取异常检测标志位</td></tr><tr><td align="center"><strong>PWMx_GET_FLAG</strong>()</td><td align="center">PWM获取通道标志位（x：0~7）</td></tr><tr><td align="center"><strong>PWM_CNT_RTZ_CLEAR_FLAG</strong>()</td><td align="center">PWM清除中断计数器标志位</td></tr><tr><td align="center"><strong>PWM_ABD_CLEAR_FLAG</strong>()</td><td align="center">PWM清除异常检测标志位</td></tr><tr><td align="center"><strong>PWMx_CLEAR_FLAG</strong>()</td><td align="center">PWM清除通道标志位（x：0~7）</td></tr></tbody></table><br><h4 id="9-PWM中断开关操作函数"><a href="#9-PWM中断开关操作函数" class="headerlink" title="9. PWM中断开关操作函数"></a>9. PWM中断开关操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>NVIC_PWM_CNT_CTRL</strong>(run)</td><td align="center">PWM计数器中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_PWM_ABD_CTRL</strong>(run)</td><td align="center">PWM异常中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_NVIC_PWM0_CTRL</strong>(run)</td><td align="center">PWM0中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_NVIC_PWM1_CTRL</strong>(run)</td><td align="center">PWM1中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_NVIC_PWM2_CTRL</strong>(run)</td><td align="center">PWM2中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_NVIC_PWM3_CTRL</strong>(run)</td><td align="center">PWM3中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_NVIC_PWM4_CTRL</strong>(run)</td><td align="center">PWM4中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_NVIC_PWM5_CTRL</strong>(run)</td><td align="center">PWM5中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_NVIC_PWM6_CTRL</strong>(run)</td><td align="center">PWM6中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_NVIC_PWM6_CTRL</strong>(run)</td><td align="center">PWM6中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_NVIC_PWM7_CTRL</strong>(run)</td><td align="center">PWM7中断开关控制（宏函数）</td></tr></tbody></table><br><h4 id="10-PWM端口切换函数（x-0-7）"><a href="#10-PWM端口切换函数（x-0-7）" class="headerlink" title="10. PWM端口切换函数（x:0~7）"></a>10. PWM端口切换函数（x:0~7）</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>GPIO_PWMx_SWPort</strong>(GPIOSWPort_Type Port);</td><td align="center">PWM端口切换</td></tr></tbody></table><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><blockquote><p>这里采用STC8A来演示。</p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;8051_ELL_Lib.h&quot;void STC8Ax_PWM_Config(void)&#123;GPIO_MODE_OUT_PP(GPIO_P2,Pin_5);GPIO_PWM5_SWPort(SW_Port1);    &#x2F;*     * PWM 周期:     * 如果系统时钟频率 &#x3D;&#x3D; 24Mhz,     * 设置 PWM_SCLK_DIV &#x3D; 1,     * 设置PWM计数器预置值 &#x3D; 0x1000( 4096 )     * 所以PWM周期 &#x3D; 24M &#x2F; (1*4096) Hz &#x3D; 5.86KHz     *      * 占空比:     * 设置初始电平 &#x3D; High level,     * 设置第一个翻转点 &#x3D; 0x100,     * 设置第二个翻转点 &#x3D; 0x500,     * 所以占空比 &#x3D; (0x1000-(0x500-0x100))&#x2F;0x1000 &#x3D; 75%     *&#x2F;PWM5_Init(PWM_Start_High_Level,0x0100,0x0500,ENABLE);PWM_CNT_Init(PWM_SCLK_DIV_1,0x1000,ENABLE);&#125;int main(void)&#123;    STC8Ax_PWM_Config();    for(;;)    &#123;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-组件篇-按键扫描</title>
      <link href="2021/03/14/8051ell-ku-she-bei-qu-dong-pian-an-jian-sao-miao-dan-jian/"/>
      <url>2021/03/14/8051ell-ku-she-bei-qu-dong-pian-an-jian-sao-miao-dan-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="设备驱动介绍"><a href="#设备驱动介绍" class="headerlink" title="设备驱动介绍"></a>设备驱动介绍</h2><p>按键，是我们日常开发中最常用的硬件设备之一，所以驱动按键成为了我们最平常也是最重要的一环。本驱动旨在帮助开发者快速实现按键驱动，简洁灵活，可拓展。</p><h3 id="详细内容"><a href="#详细内容" class="headerlink" title="详细内容"></a>详细内容</h3><p>目前本驱动支持短按触发功能，可以配置高低电平触发，按下后立即生效或放手以后才生效，可配合TMT组件使用，非常灵活。用户只需要按照给定的类型注册按键和按键事件函数，并做好初始化工作，即可实现按键功能！</p><p>实现方法，同样是利用了时间片扫描来消抖，所以需要占用一个定时器中断，或者在主函数中隔一段时间运行一次。</p><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-按键扫描初始化函数（注册按键）"><a href="#1-按键扫描初始化函数（注册按键）" class="headerlink" title="1. 按键扫描初始化函数（注册按键）"></a>1. 按键扫描初始化函数（注册按键）</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>KeyScan_Init</strong>(KeyScan_Type * keyScan)</td><td align="center">按键扫描初始化函数</td></tr></tbody></table><br><h5 id="KeyScan-Type-结构体说明"><a href="#KeyScan-Type-结构体说明" class="headerlink" title="KeyScan_Type 结构体说明"></a>KeyScan_Type 结构体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct&#123;uint8_t        GPIO;  &#x2F;* GPIO IO口组号 GPIO_P0~GPIO_P07*&#x2F;uint8_t        Pin;   &#x2F;* IO引脚号 Pin0~Pin07 *&#x2F;Sem_Effect      EffMode; &#x2F;* 按键事件的生效模式 *&#x2F;Sem_Tri         TriMode; &#x2F;* 按键扫描的触发模式 *&#x2F;KeyHandle_Func  HandleFunc;  &#x2F;* 按键的事件函数 *&#x2F;&#125;KeyScan_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="Sem-Effect-枚举体说明"><a href="#Sem-Effect-枚举体说明" class="headerlink" title="Sem_Effect 枚举体说明"></a>Sem_Effect 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum &#123;  Effect_Press   &#x3D; 0x00, &#x2F;* 按下后立刻生效 *&#x2F;  Effect_Release &#x3D; 0x01  &#x2F;* 松手后立刻生效 *&#x2F;&#125; Sem_Effect;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="KeyScan-Type-结构体说明-1"><a href="#KeyScan-Type-结构体说明-1" class="headerlink" title="KeyScan_Type 结构体说明"></a>KeyScan_Type 结构体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum &#123;  Tri_High_level &#x3D; 0x00, &#x2F;* 高电平触发 *&#x2F;  Tri_Low_level  &#x3D; 0x01  &#x2F;* 低电平触发 *&#x2F;&#125; Sem_Tri;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="2-按键扫描操作函数"><a href="#2-按键扫描操作函数" class="headerlink" title="2. 按键扫描操作函数"></a>2. 按键扫描操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>KeyScan.Run</strong>()</td><td align="center">按键扫描运行函数</td></tr><tr><td align="center">FSCSTATE <strong>KeyScan.ReadPin_P0</strong>()</td><td align="center">按键扫描读取P0口值函数</td></tr><tr><td align="center">FSCSTATE <strong>KeyScan.ReadPin_P1</strong>()</td><td align="center">按键扫描读取P1口值函数</td></tr><tr><td align="center">FSCSTATE <strong>KeyScan.ReadPin_P2</strong>()</td><td align="center">按键扫描读取P2口值函数</td></tr><tr><td align="center">FSCSTATE <strong>KeyScan.ReadPin_P3</strong>()</td><td align="center">按键扫描读取P3口值函数</td></tr><tr><td align="center">FSCSTATE <strong>KeyScan.ReadPin_P4</strong>()</td><td align="center">按键扫描读取P4口值函数</td></tr><tr><td align="center">FSCSTATE <strong>KeyScan.ReadPin_P5</strong>()</td><td align="center">按键扫描读取P5口值函数</td></tr><tr><td align="center">FSCSTATE <strong>KeyScan.ReadPin_P6</strong>()</td><td align="center">按键扫描读取P6口值函数</td></tr><tr><td align="center">FSCSTATE <strong>KeyScan.ReadPin_P7</strong>()</td><td align="center">按键扫描读取P7口值函数</td></tr></tbody></table><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><ol><li>方式一，利用定时器中断，来实现按键扫描的去抖操作，硬件上由P54连接按键，高电平触发按键</li></ol><p>在Lib_CFG文件里，配置相关参数 ；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*--------------------------------------------------------| @Description: STC8x Driver config                      |--------------------------------------------------------*&#x2F;&#x2F;**  * @name    KeyScan  * @brief   You need to config key scan.  ***&#x2F;#define  DRV_LIB_KEYSCAN_CTRL        (1)    &#x2F;&#x2F; &quot;1&quot; 开启, &quot;0&quot;关闭 #define  DRV_LIB_KEYSCAN_NUM_MAX     (8)    &#x2F;&#x2F; 按键的最大数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">static void STC8x_TIMER_Config(void) &#x2F;* 初始化定时器0 20ms终端一次 *&#x2F;&#123;TIMER_InitType TIMER_InitStruct&#x3D;&#123;0&#125;;TIMER_InitStruct.Mode &#x3D; TIMER_16BitAutoReload;TIMER_InitStruct.Value &#x3D; 20000;     &#x2F;&#x2F;20ms 系统时钟频率设置24MTIMER_InitStruct.Run &#x3D; ENABLE;TIMER0_Init(&amp;TIMER_InitStruct);NVIC_TIMER0_Init(NVIC_PR0,ENABLE);&#125;void TIMER0_ISRQ_Handler(void) &#x2F;* 定时器0中断函数 *&#x2F;&#123;KeyScan.ReadPin_P5();  &#x2F;* 由于我们是P54连的按键，就读取P5的IO值 *&#x2F;&#125;void Key_Handle(void) &#x2F;* 按键事件函数 *&#x2F;&#123;GPIO_TOGGLE_PIN(GPIO_P5,Pin_5);  &#x2F;* 翻转P55的IO电平 *&#x2F;UART1_Send_Byte(64);  &#x2F;* 串口发送64的数值 *&#x2F;&#125;int main(void)&#123;KeyScan_Type KeyScan_P54 &#x3D; &#123;0&#125;; &#x2F;* 定义一个按键结构体 *&#x2F;STC8x_TIMER_Config(); &#x2F;* 调用定时器0初始化函数 *&#x2F;    NVIC_GLOBAL_ENABLE(); &#x2F;* 初始化总中断 *&#x2F;    GPIO_MODE_IN_FLOATING(GPIO_P5,Pin_4);  &#x2F;&#x2F;P54 浮空输入GPIO_MODE_OUT_PP(GPIO_P5,Pin_5);  &#x2F;&#x2F;P55  推挽输出KeyScan_P54.GPIO &#x3D; GPIO_P5;  &#x2F;* 指明P5 *&#x2F;KeyScan_P54.Pin &#x3D; Pin_4;  &#x2F;* 指明Pin4 *&#x2F;KeyScan_P54.EffMode &#x3D; Effect_Release;  &#x2F;* 选择松手生效 *&#x2F;KeyScan_P54.TriMode &#x3D; Tri_High_level;  &#x2F;* 选择高电平触发 *&#x2F;KeyScan_P54.HandleFunc &#x3D; Key_Handle; &#x2F;* 指明按键事件函数 *&#x2F;KeyScan_Init(&amp;KeyScan_P54);  &#x2F;* 注册按键 *&#x2F;    for(;;)    &#123;KeyScan.Run();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>方式二，在主函数中每隔一段时间扫描一次（我们采用TMT组件），来实现按键扫描的去抖操作，硬件上由P54连接按键，高电平触发按键</li></ol><p>在Lib_CFG文件里，配置相关参数 ；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*--------------------------------------------------------| @Description: STC8x Driver config                      |--------------------------------------------------------*&#x2F;&#x2F;**  * @name    KeyScan  * @brief   You need to config key scan.  ***&#x2F;#define  DRV_LIB_KEYSCAN_CTRL        (1)    &#x2F;&#x2F; &quot;1&quot; 开启, &quot;0&quot;关闭 #define  DRV_LIB_KEYSCAN_NUM_MAX     (8)    &#x2F;&#x2F; 按键的最大数量&#x2F;*--------------------------------------------------------| @Description: STC8x Componets config                   |--------------------------------------------------------*&#x2F;&#x2F;**  * @name    TMT  * @brief   Task time tool***&#x2F;#define  COM_LIB_TMT_CTRL              (1)    &#x2F;&#x2F; &quot;1&quot; 开启, &quot;0&quot;关闭 #define  COM_LIB_TMT_TASK_NUM_MAX      (8)    &#x2F;&#x2F; 最大任务数量#define  COM_LIB_NVIC_TIMER_ISR_ENABLE    ET0 &#x3D; 1  &#x2F;&#x2F;定时器中断打开（根据你使用的定时器来选择）#define  COM_LIB_NVIC_TIMER_ISR_DISABLE   ET0 &#x3D; 0  &#x2F;&#x2F;定时器中断关闭（根据你使用的定时器来选择）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">static void STC8x_TIMER_Config(void) &#x2F;* 初始化定时器0 20ms终端一次 *&#x2F;&#123;TIMER_InitType TIMER_InitStruct&#x3D;&#123;0&#125;;TIMER_InitStruct.Mode &#x3D; TIMER_16BitAutoReload;TIMER_InitStruct.Value &#x3D; 1000;     &#x2F;&#x2F;1ms 系统时钟频率设置24MTIMER_InitStruct.Run &#x3D; ENABLE;TIMER0_Init(&amp;TIMER_InitStruct);NVIC_TIMER0_Init(NVIC_PR0,ENABLE);&#125;void TIMER0_ISRQ_Handler(void) &#x2F;* 定时器0中断函数 *&#x2F;&#123;    &#x2F;*    调用TMT节拍函数，为TMT提供心跳节拍，    节拍时间根据你设置的定时器中断时间来决定    *&#x2F;    TMT.Tick(); &#125;void Key_Handle(void) &#x2F;* 按键事件函数 *&#x2F;&#123;GPIO_TOGGLE_PIN(GPIO_P5,Pin_5);  &#x2F;* 翻转P55的IO电平 *&#x2F;UART1_Send_Byte(64);  &#x2F;* 串口发送64的数值 *&#x2F;&#125;int main(void)&#123;KeyScan_Type KeyScan_P54 &#x3D; &#123;0&#125;; &#x2F;* 定义一个按键结构体 *&#x2F;STC8x_TIMER_Config(); &#x2F;* 调用定时器0初始化函数 *&#x2F;    NVIC_GLOBAL_ENABLE(); &#x2F;* 初始化总中断 *&#x2F;    TMT_Init();  &#x2F;* 初始化TMT组件 *&#x2F;    GPIO_MODE_IN_FLOATING(GPIO_P5,Pin_4);  &#x2F;&#x2F;P54 浮空输入GPIO_MODE_OUT_PP(GPIO_P5,Pin_5);  &#x2F;&#x2F;P55  推挽输出KeyScan_P54.GPIO &#x3D; GPIO_P5;  &#x2F;* 指明P5 *&#x2F;KeyScan_P54.Pin &#x3D; Pin_4;  &#x2F;* 指明Pin4 *&#x2F;KeyScan_P54.EffMode &#x3D; Effect_Release;  &#x2F;* 选择松手生效 *&#x2F;KeyScan_P54.TriMode &#x3D; Tri_High_level;  &#x2F;* 选择高电平触发 *&#x2F;KeyScan_P54.HandleFunc &#x3D; Key_Handle; &#x2F;* 指明按键事件函数 *&#x2F;KeyScan_Init(&amp;KeyScan_P54);  &#x2F;* 注册按键 *&#x2F;    TMT.Create(KeyScan.ReadPin_P5,20); &#x2F;* 20ticks 运行一次 *&#x2F;    for(;;)    &#123;KeyScan.Run();        TMT.Run();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-片内外设篇-串口</title>
      <link href="2021/03/04/8051ell-ku-pian-nei-wai-she-pian-chuan-kou/"/>
      <url>2021/03/04/8051ell-ku-pian-nei-wai-she-pian-chuan-kou/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>STC8系列单片机有4个全双工异步通信接口（串口1\2\3\4）。每个串口的通讯口均可以通过功能管脚的切换功能切换到多组端口，从而实现一个串口复用为多个串口的功能。部分型号可能有所不同。</p><blockquote><p>串口1，工作模式有四种：<code>同步移位串行模式</code>、<code>可变波特率8位数据模式</code>、<code>固定波特率9位数据模式</code>、<code>可变波特率9位数据模式</code>。有四级中断优先级（0~3），在开启中断后，需要软件清理标志位。由定时器1、2做波特率发生器。可以进行多机通信，中继广播。</p></blockquote><blockquote><p>串口2，工作模式有两种：<code>可变波特率8位数据模式</code>、<code>固定波特率9位数据模式</code>。有四级中断优先级（0~3），开启中断后，需要软件清理标志位。由定时器2做波特率发生器。可中继广播。</p></blockquote><blockquote><p>串口3，工作模式有两种：<code>可变波特率8位数据模式</code>、<code>固定波特率9位数据模式</code>。有四级中断优先级（0~3），开启中断后，需要软件清理标志位。由定时器2做波特率发生器。可中继广播。</p></blockquote><blockquote><p>串口4，工作模式有两种：<code>可变波特率8位数据模式</code>、<code>固定波特率9位数据模式</code>。有四级中断优先级（0~3），开启中断后，需要软件清理标志位。由定时器2做波特率发生器。可中继广播。</p></blockquote><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-串口初始化函数"><a href="#1-串口初始化函数" class="headerlink" title="1. 串口初始化函数"></a>1. 串口初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>UART1_Init</strong>(const UART_InitType * uartx)</td><td align="center">串口1初始化</td></tr><tr><td align="center">FSCSTATE <strong>UART2_Init</strong>(const UART_InitType * uartx)</td><td align="center">串口2初始化</td></tr><tr><td align="center">FSCSTATE <strong>UART3_Init</strong>(const UART_InitType * uartx)</td><td align="center">串口3初始化</td></tr><tr><td align="center">FSCSTATE <strong>UART4_Init</strong>(const UART_InitType * uartx)</td><td align="center">串口4初始化</td></tr></tbody></table><br><h5 id="UART-InitType-结构体说明"><a href="#UART-InitType-结构体说明" class="headerlink" title="UART_InitType 结构体说明"></a>UART_InitType 结构体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct &#123;  UARTMode_Type Mode;        &#x2F;&#x2F;工作模式  UARTBRTGen_Type BRTGen;    &#x2F;&#x2F;波特率发生器  UARTBRTMode_Type BRTMode;  &#x2F;&#x2F;波特率发生器时钟模式  FUNSTATE BRTDouble;        &#x2F;&#x2F;波特率加倍（只有串口1有）  uint32 BaudRate;           &#x2F;&#x2F;波特率值  FUNSTATE MulitComm;  &#x2F;&#x2F;多机通信（只有串口1有）  FUNSTATE Relay;      &#x2F;&#x2F;中继广播  FUNSTATE RxEnable;         &#x2F;&#x2F;接收使能控制位&#125; UART_InitType;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="UARTMode-Type-枚举体说明"><a href="#UARTMode-Type-枚举体说明" class="headerlink" title="UARTMode_Type 枚举体说明"></a>UARTMode_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;UART_SyncShift  &#x3D; 0x00,  &#x2F;&#x2F;模式0：同步移位串行模式UART_8bit_BRTx  &#x3D; 0x01, &#x2F;&#x2F;模式1：8位波特率可变模式UART_9bit_Fixed &#x3D; 0x02,  &#x2F;&#x2F;模式2：9位波特率固定模式UART_9bit_BRTx  &#x3D; 0x03   &#x2F;&#x2F;模式3：9位波特率可变模式&#125;UARTMode_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="UARTBRTGen-Type-枚举体说明"><a href="#UARTBRTGen-Type-枚举体说明" class="headerlink" title="UARTBRTGen_Type 枚举体说明"></a>UARTBRTGen_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;UART_BRT_TIM1 &#x3D; 0x00,   &#x2F;&#x2F;定时器1做波特率发生器UART_BRT_TIM2 &#x3D; 0x01,   &#x2F;&#x2F;定时器2做波特率发生器UART_BRT_TIM3 &#x3D; 0x02,&#x2F;&#x2F;定时器3做波特率发生器UART_BRT_TIM4 &#x3D; 0x03 &#x2F;&#x2F;定时器4做波特率发生器&#125;UARTBRTGen_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="UARTBRTMode-Type-枚举体说明"><a href="#UARTBRTMode-Type-枚举体说明" class="headerlink" title="UARTBRTMode_Type 枚举体说明"></a>UARTBRTMode_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;    UART_BRT_1T  &#x3D; 0x00,   &#x2F;&#x2F; 波特率发生器1T模式     UART_BRT_12T &#x3D; 0x01    &#x2F;&#x2F; 波特率发生器12T模式&#125;UARTBRTMode_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="2-串口中断初始化函数"><a href="#2-串口中断初始化函数" class="headerlink" title="2. 串口中断初始化函数"></a>2. 串口中断初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE  <strong>NVIC_UART1_Init</strong>(NVICPri_Type Priority,FUNSTATE Run)</td><td align="center">串口1中断初始化</td></tr><tr><td align="center">FSCSTATE  <strong>NVIC_UART2_Init</strong>(NVICPri_Type Priority,FUNSTATE Run)</td><td align="center">串口2中断初始化</td></tr><tr><td align="center">FSCSTATE  <strong>NVIC_UART3_Init</strong>(FUNSTATE Run)</td><td align="center">串口3中断初始化</td></tr><tr><td align="center">FSCSTATE  <strong>NVIC_UART4_Init</strong>(FUNSTATE Run)</td><td align="center">串口4中断初始化</td></tr></tbody></table><blockquote><p>注：NVICPri_Type 枚举体的具体描述，详情见《中断管理》章节。</p></blockquote><br><h4 id="3-串口中断服务函数"><a href="#3-串口中断服务函数" class="headerlink" title="3. 串口中断服务函数"></a>3. 串口中断服务函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void <strong>UART1_ISRQ_Handler</strong>(void)</td><td align="center">串口1中断服务</td></tr><tr><td align="center">void <strong>UART2_ISRQ_Handler</strong>(void)</td><td align="center">串口2中断服务</td></tr><tr><td align="center">void <strong>UART3_ISRQ_Handler</strong>(void)</td><td align="center">串口3中断服务</td></tr><tr><td align="center">void <strong>UART4_ISRQ_Handler</strong>(void)</td><td align="center">串口4中断服务</td></tr></tbody></table><br><h4 id="4-串口中断控制函数"><a href="#4-串口中断控制函数" class="headerlink" title="4. 串口中断控制函数"></a>4. 串口中断控制函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>NVIC_UART1_CTRL</strong>(run)</td><td align="center">串口1中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_UART2_CTRL</strong>(run)</td><td align="center">串口2中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_UART3_CTRL</strong>(run)</td><td align="center">串口3中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_UART4_CTRL</strong>(run)</td><td align="center">串口4中断开关控制（宏函数）</td></tr></tbody></table><br><h4 id="5-串口端口切换函数"><a href="#5-串口端口切换函数" class="headerlink" title="5. 串口端口切换函数"></a>5. 串口端口切换函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>GPIO_UART1_SWPort</strong>(GPIOSWPort_Type Port)</td><td align="center">串口1端口切换</td></tr><tr><td align="center">FSCSTATE <strong>GPIO_UART2_SWPort</strong>(GPIOSWPort_Type Port)</td><td align="center">串口2端口切换</td></tr><tr><td align="center">FSCSTATE <strong>GPIO_UART3_SWPort</strong>(GPIOSWPort_Type Port))</td><td align="center">串口3端口切换</td></tr><tr><td align="center">FSCSTATE <strong>GPIO_UART4_SWPort</strong>(GPIOSWPort_Type Port)</td><td align="center">串口4端口切换</td></tr></tbody></table><br><h4 id="6-串口获取接收标志函数"><a href="#6-串口获取接收标志函数" class="headerlink" title="6. 串口获取接收标志函数"></a>6. 串口获取接收标志函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>UART1_GET_RX_FLAG</strong>()</td><td align="center">串口1获取接收标志（宏函数）</td></tr><tr><td align="center"><strong>UART2_GET_RX_FLAG</strong>()</td><td align="center">串口2获取接收标志（宏函数）</td></tr><tr><td align="center"><strong>UART3_GET_RX_FLAG</strong>()</td><td align="center">串口3获取接收标志（宏函数）</td></tr><tr><td align="center"><strong>UART4_GET_RX_FLAG</strong>()</td><td align="center">串口4获取接收标志（宏函数）</td></tr></tbody></table><br><h4 id="7-串口获取输出标志函数"><a href="#7-串口获取输出标志函数" class="headerlink" title="7. 串口获取输出标志函数"></a>7. 串口获取输出标志函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>UART1_GET_TX_FLAG</strong>()</td><td align="center">串口1获取输出标志（宏函数）</td></tr><tr><td align="center"><strong>UART2_GET_TX_FLAG</strong>()</td><td align="center">串口2获取输出标志（宏函数）</td></tr><tr><td align="center"><strong>UART3_GET_TX_FLAG</strong>()</td><td align="center">串口3获取输出标志（宏函数）</td></tr><tr><td align="center"><strong>UART4_GET_TX_FLAG</strong>()</td><td align="center">串口4获取输出标志（宏函数）</td></tr></tbody></table><br><h4 id="8-串口清理接收标志函数"><a href="#8-串口清理接收标志函数" class="headerlink" title="8. 串口清理接收标志函数"></a>8. 串口清理接收标志函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>UART1_CLEAR_RX_FLAG</strong>()</td><td align="center">串口1清理接收标志（宏函数）</td></tr><tr><td align="center"><strong>UART2_CLEAR_RX_FLAG</strong>()</td><td align="center">串口2清理接收标志（宏函数）</td></tr><tr><td align="center"><strong>UART3_CLEAR_RX_FLAG</strong>()</td><td align="center">串口3清理接收标志（宏函数）</td></tr><tr><td align="center"><strong>UART4_CLEAR_RX_FLAG</strong>()</td><td align="center">串口4清理接收标志（宏函数）</td></tr></tbody></table><br><h4 id="9-串口清理输出标志函数"><a href="#9-串口清理输出标志函数" class="headerlink" title="9. 串口清理输出标志函数"></a>9. 串口清理输出标志函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>UART1_CLEAR_TX_FLAG</strong>()</td><td align="center">串口1清理输出标志（宏函数）</td></tr><tr><td align="center"><strong>UART2_CLEAR_TX_FLAG</strong>()</td><td align="center">串口2清理输出标志（宏函数）</td></tr><tr><td align="center"><strong>UART3_CLEAR_TX_FLAG</strong>()</td><td align="center">串口3清理输出标志（宏函数）</td></tr><tr><td align="center"><strong>UART4_CLEAR_TX_FLAG</strong>()</td><td align="center">串口4清理输出标志（宏函数）</td></tr></tbody></table><br><h4 id="10-串口获取忙标志函数"><a href="#10-串口获取忙标志函数" class="headerlink" title="10. 串口获取忙标志函数"></a>10. 串口获取忙标志函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>UART1_GET_BUSY_FLAG</strong>()</td><td align="center">串口1获取忙标志（宏函数）</td></tr><tr><td align="center"><strong>UART2_GET_BUSY_FLAG</strong>()</td><td align="center">串口2获取忙标志（宏函数）</td></tr><tr><td align="center"><strong>UART3_GET_BUSY_FLAG</strong>()</td><td align="center">串口3获取忙标志（宏函数）</td></tr><tr><td align="center"><strong>UART4_GET_BUSY_FLAG</strong>()</td><td align="center">串口4获取忙标志（宏函数）</td></tr></tbody></table><br><h4 id="11-串口设置忙标志函数"><a href="#11-串口设置忙标志函数" class="headerlink" title="11. 串口设置忙标志函数"></a>11. 串口设置忙标志函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>UART1_SET_BUSY_FLAG</strong>()</td><td align="center">串口1设置忙标志（宏函数）</td></tr><tr><td align="center"><strong>UART2_SET_BUSY_FLAG</strong>()</td><td align="center">串口2设置忙标志（宏函数）</td></tr><tr><td align="center"><strong>UART3_SET_BUSY_FLAG</strong>()</td><td align="center">串口3设置忙标志（宏函数）</td></tr><tr><td align="center"><strong>UART4_SET_BUSY_FLAG</strong>()</td><td align="center">串口4设置忙标志（宏函数）</td></tr></tbody></table><br><h4 id="12-串口清理忙标志函数"><a href="#12-串口清理忙标志函数" class="headerlink" title="12. 串口清理忙标志函数"></a>12. 串口清理忙标志函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>UART1_CLEAR_BUSY_FLAG</strong>()</td><td align="center">串口1清理忙标志（宏函数）</td></tr><tr><td align="center"><strong>UART2_CLEAR_BUSY_FLAG</strong>()</td><td align="center">串口2清理忙标志（宏函数）</td></tr><tr><td align="center"><strong>UART3_CLEAR_BUSY_FLAG</strong>()</td><td align="center">串口3清理忙标志（宏函数）</td></tr><tr><td align="center"><strong>UART4_CLEAR_BUSY_FLAG</strong>()</td><td align="center">串口4清理忙标志（宏函数）</td></tr></tbody></table><br><h4 id="13-串口发送一个字节函数"><a href="#13-串口发送一个字节函数" class="headerlink" title="13.串口发送一个字节函数"></a>13.串口发送一个字节函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void <strong>UART1_Send_Byte</strong>(uint8_t  dat)</td><td align="center">串口1发送一个字节</td></tr><tr><td align="center">void <strong>UART2_Send_Byte</strong>(uint8_t  dat)</td><td align="center">串口2发送一个字节</td></tr><tr><td align="center">void <strong>UART3_Send_Byte</strong>(uint8_t  dat)</td><td align="center">串口3发送一个字节</td></tr><tr><td align="center">void <strong>UART4_Send_Byte</strong>(uint8_t  dat)</td><td align="center">串口4发送一个字节</td></tr></tbody></table><br><h4 id="14-串口接收一个字节函数"><a href="#14-串口接收一个字节函数" class="headerlink" title="14. 串口接收一个字节函数"></a>14. 串口接收一个字节函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void <strong>UART1_Rev_Byte</strong>(uint8_t * dat)</td><td align="center">串口1接收一个字节</td></tr><tr><td align="center">void <strong>UART2_Rev_Byte</strong>(uint8_t * dat)</td><td align="center">串口2接收一个字节</td></tr><tr><td align="center">void <strong>UART3_Rev_Byte</strong>(uint8_t * dat)</td><td align="center">串口3接收一个字节</td></tr><tr><td align="center">void <strong>UART4_Rev_Byte</strong>(uint8_t * dat)</td><td align="center">串口4接收一个字节</td></tr></tbody></table><br><h4 id="15-串口发送一个字符串函数"><a href="#15-串口发送一个字符串函数" class="headerlink" title="15. 串口发送一个字符串函数"></a>15. 串口发送一个字符串函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void <strong>UART1_Send_String</strong>(const uint8_t  *str)</td><td align="center">串口1发送一个字符串</td></tr><tr><td align="center">void <strong>UART2_Send_String</strong>(const uint8_t  *str)</td><td align="center">串口2发送一个字符串</td></tr><tr><td align="center">void <strong>UART3_Send_String</strong>(const uint8_t  *str)</td><td align="center">串口3发送一个字符串</td></tr><tr><td align="center">void <strong>UART4_Send_String</strong>(const uint8_t  *str)</td><td align="center">串口4发送一个字符串</td></tr></tbody></table><br><h4 id="16-串口发送一个数组函数"><a href="#16-串口发送一个数组函数" class="headerlink" title="16.串口发送一个数组函数"></a>16.串口发送一个数组函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void <strong>UART1_Send_Array</strong>(const uint8_t  *str,uint16_t  len)</td><td align="center">串口1发送一个数组</td></tr><tr><td align="center">void <strong>UART2_Send_Array</strong>(const uint8_t  *str,uint16_t  len)</td><td align="center">串口2发送一个数组</td></tr><tr><td align="center">void <strong>UART3_Send_Array</strong>(const uint8_t  *str,uint16_t  len)</td><td align="center">串口3发送一个数组</td></tr><tr><td align="center">void <strong>UART4_Send_Array</strong>(const uint8_t  *str,uint16_t  len)</td><td align="center">串口4发送一个数组</td></tr></tbody></table><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><h4 id="1-定时器演示"><a href="#1-定时器演示" class="headerlink" title="1. 定时器演示"></a>1. 定时器演示</h4><h4 id="1-串口初始化演示"><a href="#1-串口初始化演示" class="headerlink" title="1. 串口初始化演示"></a>1. 串口初始化演示</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">void STC8x_UART_Config(void)&#123;UART_InitType UART_InitStruct&#x3D;&#123;0&#125;;&#x2F;&#x2F; 定义串口初始化结构体&#x2F;* UART1 TXD *&#x2F;GPIO_MODE_OUT_PP(GPIO_P3,Pin_1); &#x2F;&#x2F;P31口设置为推挽输出&#x2F;* UART1 RXD *&#x2F;GPIO_MODEIN_FLOATING(GPIO_P3,Pin_0); &#x2F;&#x2F;P30口设置为浮空输入    UART_InitStruct.Mode &#x3D; UART_8bit_BRTx;  &#x2F;&#x2F; 工作模式： 8位波特率可变模式UART_InitStruct.BRTGen &#x3D; UART_BRT_TIM1; &#x2F;&#x2F; 波特率发生器：定时器1UART_InitStruct.BRTMode &#x3D; UART_BRT_1T;  &#x2F;&#x2F; 波特率发生器模式：1T模式UART_InitStruct.BaudRate &#x3D; 115200;  &#x2F;&#x2F; 波特率值：115200UART_InitStruct.RxEnable &#x3D; ENABLE;  &#x2F;&#x2F; 接收使能控制位：开启接收UART1_Init(&amp;UART_InitStruct);   &#x2F;&#x2F;串口1初始化函数，传入结构体地址NVIC_UART1_Init(NVIC_PR0,ENABLE); &#x2F;&#x2F;串口1中断初始化函数，0优先级，开启中断。    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-串口输出类函数演示"><a href="#2-串口输出类函数演示" class="headerlink" title="2. 串口输出类函数演示"></a>2. 串口输出类函数演示</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">uint8_t Test1 &#x3D; 0x01;  &#x2F;&#x2F; 定义一个无符号8位的变量uint8_t Test2[10] &#x3D; &#123;0,1,2,3,4,5,6,7,8,9&#125;; &#x2F;&#x2F; 定义一个无符号8位的数组，元素有十个uint8_t Test3[] &#x3D; &quot;Hello,World!&quot;; &#x2F;&#x2F; 定义一个无符号8位的数组&#x2F;字符串UART1_Send_Byte(Test1);  &#x2F;&#x2F; 串口1输出变量Test1UART1_Send_Array(Test2,10);  &#x2F;&#x2F; 串口1输出数组Test2UART1_Send_String(Test3);  &#x2F;&#x2F; 串口1输出字符串Test3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-串口接收类函数演示"><a href="#3-串口接收类函数演示" class="headerlink" title="3. 串口接收类函数演示"></a>3. 串口接收类函数演示</h4><p><strong>中断法(建议使用)</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">uint8_t Re dat &#x3D; 0; &#x2F;&#x2F; 定义一个无符号8位的变量void UART1_ISRQ_Handler(void) &#x2F;&#x2F; 串口1中断服务函数&#123;  UART1_CLEAR_BUSY_FLAG();  &#x2F;&#x2F; 串口1清理忙标志  if (UART1_GET_TX_FLAG())  &#x2F;&#x2F; 判断串口1输出标志位  &#123;    UART1_CLEAR_TX_FLAG();  &#x2F;&#x2F; 串口1清理输出标志位  &#125;  if (UART1_GET_RX_FLAG())  &#x2F;&#x2F; 判断串口1接收标志位  &#123;    UART1_CLEAR_RX_FLAG();  &#x2F;&#x2F; 串口1清理接收标志位    UART1_Rcv_Byte(&amp;Re dat); &#x2F;&#x2F; 读取接收的字节，并存入变量Re dat中  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查询法(不建议使用)</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;8051_ELL_Lib.h&quot;uint8_t Redat &#x3D; 0; &#x2F;&#x2F; 定义一个无符号8位的变量int main(void)  &#x2F;&#x2F;main 函数&#123;STC8Ax_PER_Init(); &#x2F;&#x2F; 调用MCU外设初始化函数for(;;)  &#x2F;&#x2F;无限循环体&#123;UART1_CLEAR_BUSY_FLAG();  &#x2F;&#x2F; 串口1清理忙标志        while(!UART1_GET_RX_FLAG());        UART1_CLEAR_RX_FLAG();  &#x2F;&#x2F; 串口1清理接收标志位   UART1_Rcv_Byte(&amp;Redat); &#x2F;&#x2F; 读取接收的字节，并存入变量Redat中&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-片内外设篇-定时器</title>
      <link href="2021/03/02/8051ell-ku-pian-nei-wai-she-pian-ding-shi-qi/"/>
      <url>2021/03/02/8051ell-ku-pian-nei-wai-she-pian-ding-shi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>STC8系列MCU有5个十六位定时器/计数器，1个十五位掉电唤醒定时器，部分型号可能有所不同。</p><blockquote><p>定时器/计数器0，工作模式有四种：<code>16位自动重装模式</code>、<code>16位不可重装载模式</code>、<code>8位自动重装载模式</code>、<code>不可屏蔽中断的16位自动重装载模式</code>。有四级中断优先级（0~3），在开启中断后，硬件自动清标志位，不需要软件清理。可编程时钟输出。</p></blockquote><blockquote><p>定时器/计数器1，工作模式有三种：<code>16位自动重装模式</code>、<code>16位不可重装载模式</code>、<code>8位自动重装载模式</code>。有四级中断优先级（0~3），开启中断后，硬件自动清标志位，不需要软件清理。可作为串口1的波特率发生器（12T模式下，波特率最大38400）； 可编程时钟输出。</p></blockquote><blockquote><p>定时器/计数器2,固定工作模式：<code>16位自动重装模式</code>。固定为0级中断优先级，开启中断后，需要软件清中断标志位。可作为串口1~4的波特率发生器（12T模式下，波特率最大38400）；可编程时钟输出。STC8G、STC8H系列还支持时钟8位预分频功能。</p></blockquote><blockquote><p>定时器/计数器3,固定工作模式：<code>16位自动重装模式</code>。固定为0级中断优先级，开启中断后，需要软件清中断标志位。可作为串口3的波特率发生器（12T模式下，波特率最大38400）；可编程时钟输出。STC8G、STC8H系列还支持时钟8位预分频功能。</p></blockquote><blockquote><p>定时器/计数器4,固定工作模式：<code>16位自动重装模式</code>。固定为0级中断优先级，开启中断后，需要软件清中断标志位。可作为串口4的波特率发生器（12T模式下，波特率最大38400）；可编程时钟输出。STC8G、STC8H系列还支持时钟8位预分频功能。</p></blockquote><blockquote><p>掉电唤醒定时器,是一个15位的计数器，用于唤醒处于掉电模式的MCU。</p></blockquote><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-定时器初始化函数"><a href="#1-定时器初始化函数" class="headerlink" title="1. 定时器初始化函数"></a>1. 定时器初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>TIMER0_Init</strong>(const TIMER_InitType * timerx)</td><td align="center">定时器0初始化</td></tr><tr><td align="center">FSCSTATE <strong>TIMER1_Init</strong>(const TIMER_InitType * timerx)</td><td align="center">定时器1初始化</td></tr><tr><td align="center">FSCSTATE <strong>TIMER2_Init</strong>(const TIMER_InitType * timerx)</td><td align="center">定时器2初始化</td></tr><tr><td align="center">FSCSTATE <strong>TIMER3_Init</strong>(const TIMER_InitType * timerx)</td><td align="center">定时器3初始化</td></tr><tr><td align="center">FSCSTATE <strong>TIMER4_Init</strong>(const TIMER_InitType * timerx)</td><td align="center">定时器4初始化</td></tr></tbody></table><br><h5 id="TIMER-InitType-结构体说明："><a href="#TIMER-InitType-结构体说明：" class="headerlink" title="TIMER_InitType 结构体说明："></a>TIMER_InitType 结构体说明：</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> <span class="token class-name">uint8_t</span> SysClkDiv<span class="token punctuation">;</span>       <span class="token comment">//定时器时钟预分频器，只有STC8G、STC8H才有</span> TIMERType_Type Type<span class="token punctuation">;</span>     <span class="token comment">// 定时器工作类型</span> TIMERMode_Type Mode<span class="token punctuation">;</span>     <span class="token comment">// 定时器工作模式</span> TIMERTCycle_Type TCycle<span class="token punctuation">;</span> <span class="token comment">// 指令周期</span> FUNSTATE ClkOut<span class="token punctuation">;</span>         <span class="token comment">// 可编程时钟输出</span> <span class="token class-name">uint16_t</span> value<span class="token punctuation">;</span>          <span class="token comment">// 定时器定时时间（us）</span> FUNSTATE run<span class="token punctuation">;</span>            <span class="token comment">// 运行标志位</span><span class="token punctuation">&#125;</span> TIMER_InitType<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="TIMERType-Type-枚举体说明："><a href="#TIMERType-Type-枚举体说明：" class="headerlink" title="TIMERType_Type 枚举体说明："></a>TIMERType_Type 枚举体说明：</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">&#123;</span>  TIMER_Type_Timer   <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">,</span>   <span class="token comment">// 作为定时器</span>  TIMER_Type_Counter <span class="token operator">=</span> <span class="token number">0x01</span>     <span class="token comment">// 作为计数器</span><span class="token punctuation">&#125;</span> TIMERType_Type<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="TIMERMode-Type-枚举体说明："><a href="#TIMERMode-Type-枚举体说明：" class="headerlink" title="TIMERMode_Type 枚举体说明："></a>TIMERMode_Type 枚举体说明：</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">&#123;</span>TIMER_16BitAutoReload       <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">,</span>  <span class="token comment">// 模式 0: 十六位自动重装载模式</span>TIMER_16Bit                 <span class="token operator">=</span> <span class="token number">0x01</span><span class="token punctuation">,</span>  <span class="token comment">// 模式 1: 十六位不可重装载模式</span>TIMER_8BitAutoReload        <span class="token operator">=</span> <span class="token number">0x02</span><span class="token punctuation">,</span>  <span class="token comment">// 模式 2: 八位自动重装载模式</span>TIMER_16BitAutoReloadNoMask <span class="token operator">=</span> <span class="token number">0x03</span>   <span class="token comment">// 模式 3: 不可屏蔽中断的十六位自动重装载模式</span><span class="token punctuation">&#125;</span>TIMERMode_Type<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="TIMERTCycle-Type-枚举体说明："><a href="#TIMERTCycle-Type-枚举体说明：" class="headerlink" title="TIMERTCycle_Type 枚举体说明："></a>TIMERTCycle_Type 枚举体说明：</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">&#123;</span>    TIMER_TCY_1T  <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">,</span>   <span class="token comment">//  1T模式: 执行一条指令需要1个周期</span>TIMER_TCY_12T <span class="token operator">=</span> <span class="token number">0x01</span>    <span class="token comment">// 12T模式: 执行一条指令需要12个周期（实际是系统时钟12分频）</span><span class="token punctuation">&#125;</span>TIMERTCycle_Type<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="2-定时中断初始化函数"><a href="#2-定时中断初始化函数" class="headerlink" title="2. 定时中断初始化函数"></a>2. 定时中断初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE  <strong>NVIC_TIMER0_Init</strong>(NVICPri_Type priority,FUNSTATE run)</td><td align="center">定时器0中断初始化</td></tr><tr><td align="center">FSCSTATE  <strong>NVIC_TIMER1_Init</strong>(NVICPri_Type priority,FUNSTATE run)</td><td align="center">定时器1中断初始化</td></tr><tr><td align="center">FSCSTATE  <strong>NVIC_TIMER2_Init</strong>(FUNSTATE run)</td><td align="center">定时器2中断初始化</td></tr><tr><td align="center">FSCSTATE  <strong>NVIC_TIMER3_Init</strong>(FUNSTATE run)</td><td align="center">定时器3中断初始化</td></tr><tr><td align="center">FSCSTATE  <strong>NVIC_TIMER4_Init</strong>(FUNSTATE run)</td><td align="center">定时器4中断初始化</td></tr></tbody></table><blockquote><p>注：NVICPri_Type 枚举体的具体描述，详情见《中断管理》章节。</p></blockquote><br><h4 id="3-定时器中断服务函数"><a href="#3-定时器中断服务函数" class="headerlink" title="3. 定时器中断服务函数"></a>3. 定时器中断服务函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void <strong>TIMER0_ISRQ_Handler</strong>(void)</td><td align="center">定时器0中断服务</td></tr><tr><td align="center">void <strong>TIMER1_ISRQ_Handler</strong>(void)</td><td align="center">定时器1中断服务</td></tr><tr><td align="center">void <strong>TIMER2_ISRQ_Handler</strong>(void)</td><td align="center">定时器2中断服务</td></tr><tr><td align="center">void <strong>TIMER3_ISRQ_Handler</strong>(void)</td><td align="center">定时器3中断服务</td></tr><tr><td align="center">void <strong>TIMER4_ISRQ_Handler</strong>(void)</td><td align="center">定时器4中断服务</td></tr></tbody></table><br><h4 id="4-定时器清中断标志位函数"><a href="#4-定时器清中断标志位函数" class="headerlink" title="4. 定时器清中断标志位函数"></a>4. 定时器清中断标志位函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>TIMER2_CLEAR_FLAG</strong>()</td><td align="center">定时器2清中断标志（宏函数）</td></tr><tr><td align="center"><strong>TIMER3_CLEAR_FLAG</strong>()</td><td align="center">定时器3清中断标志（宏函数）</td></tr><tr><td align="center"><strong>TIMER4_CLEAR_FLAG</strong>()</td><td align="center">定时器4清中断标志（宏函数）</td></tr></tbody></table><br><h4 id="5-定时器中断控制函数"><a href="#5-定时器中断控制函数" class="headerlink" title="5. 定时器中断控制函数"></a>5. 定时器中断控制函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>NVIC_TIMER0_CTRL</strong>(run)</td><td align="center">定时器0中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_TIMER1_CTRL</strong>(run)</td><td align="center">定时器1中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_TIMER2_CTRL</strong>(run)</td><td align="center">定时器2中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_TIMER3_CTRL</strong>(run)</td><td align="center">定时器3中断开关控制（宏函数）</td></tr><tr><td align="center"><strong>NVIC_TIMER4_CTRL</strong>(run)</td><td align="center">定时器4中断开关控制（宏函数）</td></tr></tbody></table><br><h4 id="6-掉电唤醒定时器初始化函数"><a href="#6-掉电唤醒定时器初始化函数" class="headerlink" title="6. 掉电唤醒定时器初始化函数"></a>6. 掉电唤醒定时器初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>TIMER5_Wake_Up_Power</strong>(uint16_t value,FUNSTATE run)</td><td align="center">掉电唤醒定时器初始化</td></tr></tbody></table><p>其参数描述：</p><blockquote><p>Value: 值范围 0 ~ 0x7FFF, 单位us</p></blockquote><blockquote><p>State： ENABLE / DIASBLE</p></blockquote><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><h4 id="1-定时器演示"><a href="#1-定时器演示" class="headerlink" title="1. 定时器演示"></a>1. 定时器演示</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"8051_ELL_Lib.h"</span></span><span class="token keyword">void</span> <span class="token function">STC8x_Config</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    TIMER_InitType TIMER_InitStruct<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">//定义定时器初始化结构体（本函数内只定义一次）</span>        TIMER_InitStruct<span class="token punctuation">.</span>Type <span class="token operator">=</span> TIMER_Type_Timer<span class="token punctuation">;</span>       <span class="token comment">// 工作类型：定时器</span>    TIMER_InitStruct<span class="token punctuation">.</span>Mode <span class="token operator">=</span> TIMER_16BitAutoReload<span class="token punctuation">;</span>  <span class="token comment">// 工作模式：十六位自动重装载</span>    TIMER_InitStruct<span class="token punctuation">.</span>TCycle <span class="token operator">=</span> TIMER_TCY_1T<span class="token punctuation">;</span>  <span class="token comment">// 指令周期：1T模式</span>    TIMER_InitStruct<span class="token punctuation">.</span>ClkOut <span class="token operator">=</span> DISABLE<span class="token punctuation">;</span>  <span class="token comment">// 可编程时钟输出：不输出</span>    TIMER_InitStruct<span class="token punctuation">.</span>Value <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>  <span class="token comment">// 预装载值：1000us</span>    TIMER_InitStruct<span class="token punctuation">.</span>Run <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span>  <span class="token comment">// 运行控制位：运行</span>    <span class="token function">TIMER0_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TIMER_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定时器0初始化函数，传入结构体地址              </span>    <span class="token function">NVIC_TIMER0_Init</span><span class="token punctuation">(</span>NVIC_PR0<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定时器0中断初始化函数，优先级为0，开启中断   </span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">STC8x_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">GPIO_MODE_OUT_PP</span><span class="token punctuation">(</span>GPIO_P1<span class="token punctuation">,</span>Pin_0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">TIMER0_ISRQ_Handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token class-name">uint16_t</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token operator">>=</span><span class="token number">500</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        P10 <span class="token operator">!=</span> P10<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-调电唤醒定时器演示"><a href="#2-调电唤醒定时器演示" class="headerlink" title="2. 调电唤醒定时器演示"></a>2. 调电唤醒定时器演示</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;8051_ELL_Lib.h&quot;     int main(void)&#123;    TIMER5_Wake_Up_Power(500,ENABLE); &#x2F;* 0.5ms唤醒一次 *&#x2F;    for(;;)    &#123;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-片内外设篇-时钟管理</title>
      <link href="2021/03/02/8051ell-ku-pian-nei-wai-she-pian-shi-zhong-guan-li/"/>
      <url>2021/03/02/8051ell-ku-pian-nei-wai-she-pian-shi-zhong-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>STC8系列MCU的系统时钟控制器，有三个时钟源可以选择，分别是：内部高精度24MHz的IRC、内部32KHz的IRC（误差较大）、外部晶振振荡器或者外部时钟信号。</p><p>STC8A的系统时钟是由主时钟分频而来，同时系统时钟还可以再分频到IO口输出脉冲供其他芯片使用。主时钟源有三个，可以通过配置寄存器来选择。</p><img src=" ../../../../images/8051_ell_lib/doc/system-clock-framework.png" style="zoom:75%;" /><p>要注意的是，切换内部主时钟源的时候，从IRC振荡电路停振到使能，要经过一段时间振荡器的频率才会稳定。所以要等到时钟源稳定以后再切换。STC8A、STC8C、STC8F系列时钟管理方法一致，STC8G、STC8H系列时钟管理方法一致。</p><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="系统时钟初始化函数"><a href="#系统时钟初始化函数" class="headerlink" title="系统时钟初始化函数"></a>系统时钟初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>SYSCLK_Init</strong>(const SYSCLK_InitType *sysClkn)</td><td align="center">系统时钟初始化</td></tr><tr><td align="center">uint32 Get_SysClk_FRE(void)</td><td align="center">获取系统时钟频率</td></tr></tbody></table><br><h5 id="SYSCLK-InitType-结构体说明"><a href="#SYSCLK-InitType-结构体说明" class="headerlink" title="SYSCLK_InitType  结构体说明"></a>SYSCLK_InitType  结构体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct&#123;    MCLKSrc_Type MCLKSrc;  &#x2F;* 主时钟源 *&#x2F;    uint8_t IRCTRIM;    &#x2F;* 内部IRC 频率调节器  *&#x2F;    LIRCTRIM_Type LIRCTRIM;  &#x2F;* 内部IRC 频率微调器  *&#x2F;    uint8_t MCLKDiv;  &#x2F;* 主时钟分频 range: 0 &lt;&#x3D; MDiv &lt;&#x3D; 255 *&#x2F;    uint8_t SCLKDiv;  &#x2F;* 系统时钟分频 *&#x2F;    SCLKOut_Type SCLKOutPin; &#x2F;* 选择系统时钟输出IO口 *&#x2F;      XOSCFilter_Type XOSCFilter; &#x2F;* 只有STC8H系列才有 *&#x2F;    IRCBand_Type  IRCBand; &#x2F;* 只有STC8G、STC8H系列才有 *&#x2F;&#125;   SYSCLK_InitType;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="MCLKSrc-Type-枚举体说明"><a href="#MCLKSrc-Type-枚举体说明" class="headerlink" title="MCLKSrc_Type 枚举体说明"></a>MCLKSrc_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;    AUTO &#x3D; 0x00,    HIRC &#x3D; 0x01, &#x2F;* 高精度内部 4MHz~36MHz IRC时钟源 *&#x2F;    LIRC &#x3D; 0x02, &#x2F;* 低精度内部 32KHz IRC时钟源 *&#x2F;    XOSC &#x3D; 0x03,  &#x2F;* 外部时钟源 *&#x2F;    X32KSC &#x3D; 0x04  &#x2F;* 外部32K时钟晶振控制，只有STC8H系列才有 *&#x2F;&#125;   MCLKSrc_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="MCLKSrc-Type-枚举体说明-1"><a href="#MCLKSrc-Type-枚举体说明-1" class="headerlink" title="MCLKSrc_Type 枚举体说明"></a>MCLKSrc_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;    TRIM0 &#x3D; 0x00, &#x2F;* 不调整 *&#x2F;    TRIM1 &#x3D; 0x01, &#x2F;* 调整约0.10%  *&#x2F;    TRIM2 &#x3D; 0x02, &#x2F;* 调整约0.04%  *&#x2F;    TRIM3 &#x3D; 0x03  &#x2F;* 调整约0.10%  *&#x2F;&#125;   LIRCTRIM_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="SCLKOut-Type-枚举体说明"><a href="#SCLKOut-Type-枚举体说明" class="headerlink" title="SCLKOut_Type 枚举体说明"></a>SCLKOut_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;    SCLK_OUT_P54 &#x3D; 0, &#x2F;* 输出到P54 *&#x2F;    SCLK_OUT_P16      &#x2F;* 输出到P16 *&#x2F;&#125;   SCLKOut_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="XOSCFilter-Type-枚举体说明"><a href="#XOSCFilter-Type-枚举体说明" class="headerlink" title="XOSCFilter_Type 枚举体说明"></a>XOSCFilter_Type 枚举体说明</h5><blockquote><p>只有STC8H系列才有</p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;    XOSC_Filter_150MHz &#x3D; 0x00,  &#x2F;* 过滤150Mhz *&#x2F;    XOSC_Filter_125MHz &#x3D; 0x01,  &#x2F;* 过滤125Mhz *&#x2F;    XOSC_Filter_66MHz  &#x3D; 0x02,  &#x2F;* 过滤66Mhz  *&#x2F;    XOSC_Filter_Null   &#x3D; 0x03   &#x2F;* 过滤无效 *&#x2F;&#125;   XOSCFilter_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h5 id="IRCBand-Type-枚举体说明"><a href="#IRCBand-Type-枚举体说明" class="headerlink" title="IRCBand_Type 枚举体说明"></a>IRCBand_Type 枚举体说明</h5><blockquote><p>只有STC8G、STC8H系列才有</p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;    IRC_Band_20MHz &#x3D; 0x00,    IRC_Band_33MHz &#x3D; 0x01, &#x2F;* 只有STC8G系列才有 *&#x2F;    IRC_Band_35MHz &#x3D; 0x01  &#x2F;* 只有STC8H系列才有 *&#x2F;&#125;   IRCBand_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><h4 id="1-系统时钟初始化"><a href="#1-系统时钟初始化" class="headerlink" title="1.系统时钟初始化"></a>1.系统时钟初始化</h4><p>我们提供两种办法来配置系统时钟频率，一种是通过stc-isp助手直接设置，一种是程序手动设置，都非常简单。</p><p>如果是使用内部IRC时钟，就先选择对应的IRC频率：</p><img src=" ../../../../images/8051_ell_lib/doc/system-clock-manage1.jpg" style="zoom:75%;" /><p>再勾选下载重要参数：</p><img src=" ../../../../images/8051_ell_lib/doc/system-clock-manage2.jpg" style="zoom:75%;" /><p>同时在函数里配置：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void STC8x_SYSCLK_Config(void)&#123;SYSCLK_InitType SYSCLK_InitStruct&#x3D;&#123;0&#125;; &#x2F;* 定义系统时钟初始化结构体 *&#x2F;        SYSCLK_InitStruct.MCLKSrc &#x3D; AUTO;  &#x2F;* 这里选择自动，通过助手配置IRC频率 *&#x2F;SYSCLK_InitStruct.SCLKDiv &#x3D; 0; &#x2F;* 系统时钟0分频，此时不对外输出脉冲信号 *&#x2F;SYSCLK_InitStruct.SCLKOutPin &#x3D; SCLK_OUT_P54; &#x2F;* 如果SCLKDiv&#x3D;&#x3D;0，此选项无效 *&#x2F;SYSCLK_Init(&amp;SYSCLK_InitStruct); &#x2F;* 传入结构体地址，完成系统时钟初始化 *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是手动设置，就需要这样来配置：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void STC8x_SYSCLK_Config(void)&#123;SYSCLK_InitType SYSCLK_InitStruct&#x3D;&#123;0&#125;; &#x2F;* 定义系统时钟初始化结构体 *&#x2F;        &#x2F;&#x2F;使用程序设置：系统频率为：24M （24M &#x2F; 1HZ）SYSCLK_InitStruct.MCLKSrc &#x3D; HIRC;  &#x2F;* 主时钟源选择 内部高精度时钟*&#x2F;    &#x2F;&#x2F; SYSCLK_InitStruct.IRCBand &#x3D; IRC_Band_20MHz; &#x2F;* STC8G、STC8H系列还要选择频段 *&#x2F;    SYSCLK_InitStruct.IRCTRIM &#x3D; 160;   &#x2F;*主时钟频率调整到 24M左右 *&#x2F;SYSCLK_InitStruct.LIRCTRIM &#x3D; 1;  &#x2F;* 主时钟微调 0.01% *&#x2F;SYSCLK_InitStruct.MCLKDiv &#x3D; 1;   &#x2F;* 主时钟1分频 *&#x2F;SYSCLK_InitStruct.SCLKDiv &#x3D; 0; &#x2F;* 系统时钟0分频，此时不对外输出脉冲信号 *&#x2F;SYSCLK_InitStruct.SCLKOutPin &#x3D; SCLK_OUT_P54; &#x2F;* 如果SCLKDiv&#x3D;&#x3D;0，此选项无效 *&#x2F;SYSCLK_Init(&amp;SYSCLK_InitStruct); &#x2F;* 传入结构体地址，完成系统时钟初始化 *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>SYSCLK_InitStruct.IRCTRIM</code>计算主时钟频率的方法参考如下：</p><img src=" ../../../../images/8051_ell_lib/doc/system-clock-manage3.jpg" style="zoom:75%;" /><h4 id="2-调用函数"><a href="#2-调用函数" class="headerlink" title="2.调用函数"></a>2.调用函数</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;8051_ELL_Lib.h&quot;uint32_t SYSCLK_FRE;int main(void)&#123;    STC8x_SYSCLK_Config(); &#x2F;&#x2F;初始化系统时钟    STC8x_UART_Config(); &#x2F;&#x2F;初始化串口        SYSCLK_FRE &#x3D; Get_Sysclk_FRE();  &#x2F;&#x2F;获取系统时钟频率        &#x2F;&#x2F;通过串口助手打印出来观察UART1_Send_Byte(SYSCLK_FRE&gt;&gt;24);UART1_Send_Byte(SYSCLK_FRE&gt;&gt;16);UART1_Send_Byte(SYSCLK_FRE&gt;&gt;8);UART1_Send_Byte(SYSCLK_FRE&gt;&gt;0);    for(;;)    &#123;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-片内外设篇-IO口</title>
      <link href="2021/03/02/8051ell-ku-pian-nei-wai-she-pian-io-kou/"/>
      <url>2021/03/02/8051ell-ku-pian-nei-wai-she-pian-io-kou/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>GPIO是MCU最基本的外设之一，也是使用最频繁的外设。STC8的GPIO有四种工作模式，分别是准双向口/弱上拉、推挽输出/强上拉、高阻输入/浮空输入、开漏输出。同时IO口还具有一个可控的施密特触发器，并且能设置IO口的工作速度、电流大小以及一个4.1K上拉电阻。</p><img src=" ../../../../images/8051_ell_lib/doc/GPIO-mode.png" style="zoom:75%;" /><p>为了统一管理，所有关于GPIO口的操作，基本都归结在本模块，其中就包括各外设的工作IO口切换。但是为了模块化讲解，关于IO口切换的内容，放在对应的外设模块里面作具体说明。</p><p><strong>特别注意：</strong>建议整个芯片的工作电流不要超过70mA,IO口的工作电流控制在20mA左右。</p><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-GPIO初始化函数"><a href="#1-GPIO初始化函数" class="headerlink" title="1. GPIO初始化函数"></a>1. GPIO初始化函数</h4><blockquote><p>GPIO_Px：必须是0~7</p></blockquote><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>GPIO_MODE_WEAK_PULL</strong>(GPIO_Px,Pin)</td><td align="center">IO口准双向口模式（宏函数）</td></tr><tr><td align="center"><strong>GPIO_MODE_IN_FLOATING</strong>(GPIO_Px,Pin)</td><td align="center">IO口浮空输入模式（宏函数）</td></tr><tr><td align="center"><strong>GPIO_MODE_OUT_OD</strong>(GPIO_Px,Pin)</td><td align="center">IO口开漏输出模式（宏函数）</td></tr><tr><td align="center"><strong>GPIO_MODE_OUT_PP</strong>(GPIO_Px,Pin)</td><td align="center">IO口推挽输出模式（宏函数）</td></tr></tbody></table><br><h4 id="2-GPIO上拉电阻控制函数"><a href="#2-GPIO上拉电阻控制函数" class="headerlink" title="2. GPIO上拉电阻控制函数"></a>2. GPIO上拉电阻控制函数</h4><blockquote><p>GPIO_Px：必须是0~7</p></blockquote><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>GPIO_PULL_UP_ENABLE</strong>(GPIO_Px,Pin)</td><td align="center">IO口使能上拉4.1k电阻（宏函数）</td></tr><tr><td align="center"><strong>GPIO_PULL_UP_DISABLE</strong>(GPIO_Px,Pin)</td><td align="center">IO口禁止上拉4.1k电阻（宏函数）</td></tr></tbody></table><br><h4 id="3-GPIO施密特触发器控制函数"><a href="#3-GPIO施密特触发器控制函数" class="headerlink" title="3. GPIO施密特触发器控制函数"></a>3. GPIO施密特触发器控制函数</h4><blockquote><p>GPIO_Px：必须是0~7</p></blockquote><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>GPIO_ST_ENABLE</strong>(GPIO_Px,Pin)</td><td align="center">IO口使能施密特触发器（宏函数）</td></tr><tr><td align="center"><strong>GPIO_ST_DISABLE</strong>(GPIO_Px,Pin)</td><td align="center">IO口禁止施密特触发器（宏函数）</td></tr></tbody></table><br><h4 id="4-GPIO电平翻转速度控制函数"><a href="#4-GPIO电平翻转速度控制函数" class="headerlink" title="4. GPIO电平翻转速度控制函数"></a>4. GPIO电平翻转速度控制函数</h4><blockquote><p>GPIO_Px：必须是0~7</p></blockquote><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>GPIO_SPEED_LOW</strong>(GPIO_Px,Pin)</td><td align="center">IO口低速翻转电平（宏函数）</td></tr><tr><td align="center"><strong>GPIO_SPEED_HIGH</strong>(GPIO_Px,Pin)</td><td align="center">IO口高速翻转电平（宏函数）</td></tr></tbody></table><br><h4 id="5-GPIO驱动电流控制函数"><a href="#5-GPIO驱动电流控制函数" class="headerlink" title="5. GPIO驱动电流控制函数"></a>5. GPIO驱动电流控制函数</h4><blockquote><p>GPIO_Px：必须是0~7</p></blockquote><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>GPIO_DRIVE_MEDIUM</strong>(GPIO_Px,Pin)</td><td align="center">IO口普通驱动电流（宏函数）</td></tr><tr><td align="center"><strong>GPIO_DRIVE_HIGH</strong>(GPIO_Px,Pin)</td><td align="center">IO口大驱动电流（宏函数）</td></tr></tbody></table><br><h4 id="6-GPIO引脚翻转控制函数"><a href="#6-GPIO引脚翻转控制函数" class="headerlink" title="6. GPIO引脚翻转控制函数"></a>6. GPIO引脚翻转控制函数</h4><blockquote><p>GPIO_Px：必须是0~7</p></blockquote><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>GPIO_TOGGLE_PIN</strong>(GPIO_Px,Pin)</td><td align="center">IO口翻转控制（宏函数）</td></tr></tbody></table><br><h5 id="IO口Pin-参数宏定义说明"><a href="#IO口Pin-参数宏定义说明" class="headerlink" title="IO口Pin 参数宏定义说明"></a>IO口Pin 参数宏定义说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* GPIO *&#x2F;#defineGPIO_P0      &#x2F;&#x2F;IO P0#defineGPIO_P1      &#x2F;&#x2F;IO P1#defineGPIO_P2      &#x2F;&#x2F;IO P2#defineGPIO_P3      &#x2F;&#x2F;IO P3#defineGPIO_P4      &#x2F;&#x2F;IO P4#defineGPIO_P5      &#x2F;&#x2F;IO P5#defineGPIO_P6      &#x2F;&#x2F;IO P6#defineGPIO_P7      &#x2F;&#x2F;IO P7&#x2F;* Pin *&#x2F;#definePin_0    0x01  &#x2F;&#x2F;IO Pin Px.0#definePin_1    0x02  &#x2F;&#x2F;IO Pin Px.1#definePin_2    0x04  &#x2F;&#x2F;IO Pin Px.2#definePin_3    0x08  &#x2F;&#x2F;IO Pin Px.3#definePin_4    0x10  &#x2F;&#x2F;IO Pin Px.4#definePin_5    0x20  &#x2F;&#x2F;IO Pin Px.5#definePin_6    0x40  &#x2F;&#x2F;IO Pin Px.6#definePin_7    0x80  &#x2F;&#x2F;IO Pin Px.7#definePin_All  0xFF  &#x2F;&#x2F;IO All  Pin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;STC8x_GPIO.h&quot;int main(void)&#123;    GPIO_MODE_OUT_PP(GPIO_P1,Pin_1); &#x2F;*将P11设置为推挽输出*&#x2F;    P11 &#x3D; 0; &#x2F;&#x2F;P11输出低电平    for(;;)    &#123;           &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-片内外设篇-可编程计数器</title>
      <link href="2021/03/01/8051ell-ku-pian-nei-wai-she-pian-ke-bian-cheng-ji-shu-qi/"/>
      <url>2021/03/01/8051ell-ku-pian-nei-wai-she-pian-ke-bian-cheng-ji-shu-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="STC8系列"><a href="#STC8系列" class="headerlink" title="STC8系列"></a>STC8系列</h2><h3 id="外设介绍"><a href="#外设介绍" class="headerlink" title="外设介绍"></a>外设介绍</h3><p>STC8内部集成了可编程计数器阵列模块，可用于软件定时器、外部脉冲捕获、高速脉冲输出和PWM脉宽调制输出。STC8A系列内部有四组，其他系列可能有所不同。</p><p>函数库提供了可编程计数器的四种应用方案，可以用于扩展定时器、PWM、高速脉冲输出、输入捕获。</p><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><h4 id="1-PCA计数器初始化函数"><a href="#1-PCA计数器初始化函数" class="headerlink" title="1. PCA计数器初始化函数"></a>1. PCA计数器初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>PCA_CNT_Init</strong>(PCACLKSrc_Type clkSrc,FUNSTATE run)</td><td align="center">PCA计数器初始化</td></tr></tbody></table><br><h5 id="SPIClkSrc-Type-枚举体说明"><a href="#SPIClkSrc-Type-枚举体说明" class="headerlink" title="SPIClkSrc_Type 枚举体说明"></a>SPIClkSrc_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;  PCA_SCLK_DIV_12 &#x3D; 0x00,  &#x2F;&#x2F; 系统时钟12分频做时钟源  PCA_SCLK_DIV_2  &#x3D; 0x02,  &#x2F;&#x2F; 系统时钟2分频做时钟源  PCA_TIMER0      &#x3D; 0x04,  &#x2F;&#x2F; 定时器0溢出脉冲做时钟源  PCA_ECI         &#x3D; 0x06,  &#x2F;&#x2F; ECI引脚外部输入时钟做时钟源  PCA_SCLK_DIV_1  &#x3D; 0x08,  &#x2F;&#x2F; 系统时钟1分频做时钟源  PCA_SCLK_DIV_4  &#x3D; 0x0A,  &#x2F;&#x2F; 系统时钟4分频做时钟源  PCA_SCLK_DIV_6  &#x3D; 0x0C,  &#x2F;&#x2F; 系统时钟6分频做时钟源  PCA_SCLK_DIV_8  &#x3D; 0x0E   &#x2F;&#x2F; 系统时钟8分频做时钟源&#125;  PCACLKSrc_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="2-PCA作为PWM操作函数"><a href="#2-PCA作为PWM操作函数" class="headerlink" title="2. PCA作为PWM操作函数"></a>2. PCA作为PWM操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>PCA0_PWM_Init</strong>(PCA_PWMBits_Type pwmBits,uint16_t duty)</td><td align="center">PCA0作为PWM初始化</td></tr><tr><td align="center">FSCSTATE <strong>PCA1_PWM_Init</strong>(PCA_PWMBits_Type pwmBits,uint16_t duty)</td><td align="center">PCA1作为PWM初始化</td></tr><tr><td align="center">FSCSTATE <strong>PCA2_PWM_Init</strong>(PCA_PWMBits_Type pwmBits,uint16_t duty)</td><td align="center">PCA2作为PWM初始化</td></tr><tr><td align="center">FSCSTATE <strong>PCA3_PWM_Init</strong>(PCA_PWMBits_Type pwmBits,uint16_t duty)</td><td align="center">PCA3作为PWM初始化</td></tr></tbody></table><br><h5 id="PCA-PWMBits-Type-枚举体说明"><a href="#PCA-PWMBits-Type-枚举体说明" class="headerlink" title="PCA_PWMBits_Type  枚举体说明"></a>PCA_PWMBits_Type  枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;PCA_PWM_8Bit  &#x3D; 0x00,   &#x2F;&#x2F; 8位分辨率PWM模式 PCA_PWM_7Bit  &#x3D; 0x01,&#x2F;&#x2F; 7位分辨率PWM模式PCA_PWM_6Bit  &#x3D; 0x02,&#x2F;&#x2F; 6位分辨率PWM模式PCA_PWM_10Bit &#x3D; 0x03&#x2F;&#x2F; 10位分辨率PWM模式&#125;PCA_PWMBits_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>PCAx_PWM_6BITS_CTRL</strong>(duty)</td><td align="center">PCAx作为6位PWM初始化和控制</td></tr><tr><td align="center">FSCSTATE <strong>PCAx_PWM_7BITS_CTRL</strong>(duty)</td><td align="center">PCAx作为7位PWM初始化和控制</td></tr><tr><td align="center">FSCSTATE <strong>PCAx_PWM_8BITS_CTRL</strong>(duty)</td><td align="center">PCAx作为8位PWM初始化和控制</td></tr><tr><td align="center">FSCSTATE <strong>PCAx_PWM_10BITS_CTRL</strong>(duty)</td><td align="center">PCAx作为10位PWM初始化和控制</td></tr></tbody></table><br><h5 id="Duty：-占空比计算说明"><a href="#Duty：-占空比计算说明" class="headerlink" title="Duty： 占空比计算说明"></a><strong>Duty：</strong> 占空比计算说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;**  * 说明： 1. xxH：H为十六进制表示，C语言代码里用0x表示;  *       2.CLKSrc：为PCA_CNT时钟源,单位Hz;***&#x2F;6位分辨率模式：占空比 &#x3D; (40H-duty)&#x2F;40H频率  &#x3D; CLKSrc&#x2F;647位分辨率模式：占空比 &#x3D; (80H-duty)&#x2F;80H频率  &#x3D; CLKSrc&#x2F;128 8位分辨率模式：占空比 &#x3D; (100H-duty)&#x2F;100H频率  &#x3D; CLKSrc&#x2F;25610位分辨率模式：占空比 &#x3D; (400H-duty)&#x2F;400H频率  &#x3D; CLKSrc&#x2F;1024    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="2-PCA作为定时器操作函数"><a href="#2-PCA作为定时器操作函数" class="headerlink" title="2. PCA作为定时器操作函数"></a>2. PCA作为定时器操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>PCA0_TIM_Init</strong>(uint16_t value)</td><td align="center">PCA0作为定时器初始化</td></tr><tr><td align="center">FSCSTATE <strong>PCA1_TIM_Init</strong>(uint16_t value)</td><td align="center">PCA1作为定时器初始化</td></tr><tr><td align="center">FSCSTATE <strong>PCA2_TIM_Init</strong>(uint16_t value)</td><td align="center">PCA2作为定时器初始化</td></tr><tr><td align="center">FSCSTATE <strong>PCA3_TIM_Init</strong>(uint16_t value)</td><td align="center">PCA3作为定时器初始化</td></tr></tbody></table><p><strong>Value：</strong> 计数器预置值</p><br><h4 id="3-PCA作为高速脉冲输出操作函数"><a href="#3-PCA作为高速脉冲输出操作函数" class="headerlink" title="3. PCA作为高速脉冲输出操作函数"></a>3. PCA作为高速脉冲输出操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>PCA0_POP_Init</strong>(uint16_t value)</td><td align="center">PCA0作为POP初始化</td></tr><tr><td align="center">FSCSTATE <strong>PCA1_POP_Init</strong>(uint16_t value)</td><td align="center">PCA1作为POP初始化</td></tr><tr><td align="center">FSCSTATE <strong>PCA2_POP_Init</strong>(uint16_t value)</td><td align="center">PCA2作为POP初始化</td></tr><tr><td align="center">FSCSTATE <strong>PCA3_POP_Init</strong>(uint16_t value)</td><td align="center">PCA3作为POP初始化</td></tr></tbody></table><p><strong>Value：</strong> 计数器预置值</p><br><h4 id="4-PCA作为输入捕获操作函数"><a href="#4-PCA作为输入捕获操作函数" class="headerlink" title="4. PCA作为输入捕获操作函数"></a>4. PCA作为输入捕获操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>PCA0_CAP_Init</strong>(CAPMode_Type Mode)</td><td align="center">PCA0作为CAP初始化</td></tr><tr><td align="center">FSCSTATE <strong>PCA1_CAP_Init</strong>(CAPMode_Type Mode)</td><td align="center">PCA1作为CAP初始化</td></tr><tr><td align="center">FSCSTATE <strong>PCA2_CAP_Init</strong>(CAPMode_Type Mode)</td><td align="center">PCA2作为CAP初始化</td></tr><tr><td align="center">FSCSTATE <strong>PCA3_CAP_Init</strong>(CAPMode_Type Mode)</td><td align="center">PCA3作为CAP初始化</td></tr></tbody></table><br><h5 id="CAPMode-Type-枚举体说明"><a href="#CAPMode-Type-枚举体说明" class="headerlink" title="CAPMode_Type 枚举体说明"></a>CAPMode_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;  CAP_Mode_Falling &#x3D; 0x01,  &#x2F;&#x2F;下降沿触发  CAP_Mode_Rising  &#x3D; 0X02,  &#x2F;&#x2F;上升沿触发  CAP_Mode_Edge   &#x3D; 0x03    &#x2F;&#x2F;边沿触发&#125; CAPMode_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="4-PCA重装载值操作函数"><a href="#4-PCA重装载值操作函数" class="headerlink" title="4. PCA重装载值操作函数"></a>4. PCA重装载值操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void <strong>PCA0_TIM_POP_ReValue</strong>(void)</td><td align="center">PCA0定时器和高速脉冲计数重装载值</td></tr><tr><td align="center">void <strong>PCA1_TIM_POP_ReValue</strong>(void)</td><td align="center">PCA1定时器和高速脉冲计数重装载值</td></tr><tr><td align="center">void <strong>PCA2_TIM_POP_ReValue</strong>(void)</td><td align="center">PCA2定时器和高速脉冲计数重装载值</td></tr><tr><td align="center">void <strong>PCA3_TIM_POP_ReValue</strong>(void)</td><td align="center">PCA3定时器和高速脉冲计数重装载值</td></tr></tbody></table><br><h4 id="5-PCA通道暂停函数"><a href="#5-PCA通道暂停函数" class="headerlink" title="5. PCA通道暂停函数"></a>5. PCA通道暂停函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void <strong>PCA0_WORK_STOP</strong>()</td><td align="center">PCA0通道暂停（宏函数）</td></tr><tr><td align="center">void <strong>PCA1_WORK_STOP</strong>()</td><td align="center">PCA1通道暂停（宏函数）</td></tr><tr><td align="center">void <strong>PCA2_WORK_STOP</strong>()</td><td align="center">PCA2通道暂停（宏函数）</td></tr><tr><td align="center">void <strong>PCA3_WORK_STOP</strong>()</td><td align="center">PCA3通道暂停（宏函数）</td></tr></tbody></table><br><h4 id="6-PCA计数器中断初始化函数"><a href="#6-PCA计数器中断初始化函数" class="headerlink" title="6. PCA计数器中断初始化函数"></a>6. PCA计数器中断初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>NVIC_PCA_CNT_Init</strong>(NVICPri_Type Priority,FUNSTATE Run)</td><td align="center">PCA计数器中断初始化</td></tr></tbody></table><br><h4 id="7-PCA作为TIM或POP中断初始化函数"><a href="#7-PCA作为TIM或POP中断初始化函数" class="headerlink" title="7. PCA作为TIM或POP中断初始化函数"></a>7. PCA作为TIM或POP中断初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>NVIC_PCA0_TIM_POP_Init</strong>(FUNSTATE Run)</td><td align="center">PCA0作为TIM或POP中断初始化</td></tr><tr><td align="center">FSCSTATE <strong>NVIC_PCA1_TIM_POP_Init</strong>(FUNSTATE Run)</td><td align="center">PCA1作为TIM或POP中断初始化</td></tr><tr><td align="center">FSCSTATE <strong>NVIC_PCA2_TIM_POP_Init</strong>(FUNSTATE Run)</td><td align="center">PCA2作为TIM或POP中断初始化</td></tr><tr><td align="center">FSCSTATE <strong>NVIC_PCA3_TIM_POP_Init</strong>(FUNSTATE Run)</td><td align="center">PCA3作为TIM或POP中断初始化</td></tr></tbody></table><br><h4 id="8-PCA作为PWM或CAP中断初始化函数"><a href="#8-PCA作为PWM或CAP中断初始化函数" class="headerlink" title="8. PCA作为PWM或CAP中断初始化函数"></a>8. PCA作为PWM或CAP中断初始化函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>NVIC_PCA0_PWM_CAP_Init</strong>(PCATri_Type triMode,FUNSTATE Run)</td><td align="center">PCA0作为PWM或CAP中断初始化</td></tr><tr><td align="center">FSCSTATE <strong>NVIC_PCA1_PWM_CAP_Init</strong>(PCATri_Type triMode,FUNSTATE Run)</td><td align="center">PCA1作为PWM或CAP中断初始化</td></tr><tr><td align="center">FSCSTATE <strong>NVIC_PCA2_PWM_CAP_Init</strong>(PCATri_Type triMode,FUNSTATE Run)</td><td align="center">PCA2作为PWM或CAP中断初始化</td></tr><tr><td align="center">FSCSTATE <strong>NVIC_PCA3_PWM_CAP_Init</strong>(PCATri_Type triMode,FUNSTATE Run)</td><td align="center">PCA3作为PWM或CAP中断初始化</td></tr></tbody></table><br><h5 id="PCATri-Type-枚举体说明"><a href="#PCATri-Type-枚举体说明" class="headerlink" title="PCATri_Type 枚举体说明"></a>PCATri_Type 枚举体说明</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum&#123;   PCA_Tri_Null    &#x3D; 0x00,  &#x2F;&#x2F;无操作  PCA_Tri_Falling &#x3D; 0x10, &#x2F;&#x2F;下降沿触发  PCA_Tri_Rising  &#x3D; 0x20, &#x2F;&#x2F;上升沿触发  PCA_Tri_Edge    &#x3D; 0x30  &#x2F;&#x2F;边沿触发&#125; PCATri_Type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="9-PCA计数器中断操作函数"><a href="#9-PCA计数器中断操作函数" class="headerlink" title="9. PCA计数器中断操作函数"></a>9. PCA计数器中断操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>PCA_CNT_GET_FLAG</strong>()</td><td align="center">PCA获取计数器溢出中断标志位（宏函数）</td></tr><tr><td align="center"><strong>PCA_CNT_CLEAR_FLAG</strong>()</td><td align="center">PCA清除计数器溢出中断标志位（宏函数）</td></tr></tbody></table><br><h4 id="10-PCA各通道中断操作函数"><a href="#10-PCA各通道中断操作函数" class="headerlink" title="10. PCA各通道中断操作函数"></a>10. PCA各通道中断操作函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>PCA0_GET_FLAG</strong>()</td><td align="center">PCA0获取中断标志位（宏函数）</td></tr><tr><td align="center"><strong>PCA1_GET_FLAG</strong>()</td><td align="center">PCA1获取中断标志位（宏函数）</td></tr><tr><td align="center"><strong>PCA2_GET_FLAG</strong>()</td><td align="center">PCA2获取中断标志位（宏函数）</td></tr><tr><td align="center"><strong>PCA3_GET_FLAG</strong>()</td><td align="center">PCA3获取中断标志位（宏函数）</td></tr><tr><td align="center"><strong>PCA0_CLEAR_FLAG</strong>()</td><td align="center">PCA0清除中断标志位（宏函数）</td></tr><tr><td align="center"><strong>PCA1_CLEAR_FLAG</strong>()</td><td align="center">PCA1清除中断标志位（宏函数）</td></tr><tr><td align="center"><strong>PCA2_CLEAR_FLAG</strong>()</td><td align="center">PCA2清除中断标志位（宏函数）</td></tr><tr><td align="center"><strong>PCA3_CLEAR_FLAG</strong>()</td><td align="center">PCA3清除中断标志位（宏函数）</td></tr></tbody></table><br><h4 id="11-PCA中断服务函数"><a href="#11-PCA中断服务函数" class="headerlink" title="11. PCA中断服务函数"></a>11. PCA中断服务函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void <strong>PCA_ISRQ_Handler</strong>(void)</td><td align="center">PCA中断服务（宏函数）</td></tr></tbody></table><br><h4 id="12-PCA端口切换函数"><a href="#12-PCA端口切换函数" class="headerlink" title="12. PCA端口切换函数"></a>12. PCA端口切换函数</h4><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">FSCSTATE <strong>GPIO_PCA_SWPort</strong>(GPIOSWPort_Type Port);</td><td align="center">SPI端口切换</td></tr></tbody></table><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><blockquote><p>这里以PCA作为扩展定时器演示：</p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;8051_ELL_Lib.h&quot;void STC8x_PCA_Config(void)&#123;    &#x2F;* 先初始化PCA_TIM *&#x2F;PCA0_TIM_Init(1000);   &#x2F;&#x2F;定时1sNVIC_PCA0_TIM_POP_Init(ENABLE); &#x2F;&#x2F;启动中断    &#x2F;* 再初始化 PCA_CNT *&#x2F;PCA_CNT_Init(PCA_SCLK,ENABLE);  NVIC_PCA_CNT_Init(NVIC_PR1,DISABLE); &#x2F;&#x2F;启动PCA计数器&#125;void PCA_ISRQ_Handler(void)&#123;    if(PCA0_GET_FLAG())    &#123;        PCA0_CLEAR_FLAG();        PCA0_TIM_POP_ReValue();  &#x2F;&#x2F;计数器重装载        P10 &#x3D;!P10;    &#125;&#125;int main(void)&#123;    STC8x_PCA_Config();    for(;;)    &#123;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-组件篇-任务管理工具</title>
      <link href="2021/03/01/8051ell-ku-zu-jian-pian-ren-wu-guan-li-gong-ju/"/>
      <url>2021/03/01/8051ell-ku-zu-jian-pian-ren-wu-guan-li-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h2><p>任务管理工具的本质是时间片进程管理方法。该组件优化了这种分配时间进程的方式，更加灵活易用。</p><h3 id="详细内容"><a href="#详细内容" class="headerlink" title="详细内容"></a>详细内容</h3><p>裸机开发中，我们常用的一种程序框架是前后台系统，即中断服务函数为前台，main函数内的无限循环体为后台。变量在前台计数，到达设定的计数值（即一定时间）后，置出相应的标志位，然后在后台判断，并执行相应的代码。</p><img src=" ../../../../images/8051_ell_lib/doc/TMT_1.png" style="zoom:75%;" /><p>传统的前后台系统，虽然是一个比较合理的框架，但是有一些缺点，非常令人头疼。比如变量的传递，尤其设置标志位，一般都是全局变量，且跨文件调用，当分配的全局变量过多时，会降低代码的阅读性和维护性，同时也会存在堆栈溢出的风险，大大影响系统的稳定性。</p><p>本组件模块在前后台系统的基础上，进行了优化，通过结构体封装+中断回调函数的方式，基本上避免了以上所述的问题，使我们整个的程序框架更加稳定简洁。</p><p>要说明的是，本模块根据时间片来管理任务进程的，无优先级。任务的执行顺序与分配的时间有关，时间越小，越先执行。如果两个任务被分配的时间相同，先分配的任务，先执行。</p><p>但是不建议将两个任务分配相同的时间或者特别相近，避免发出冲突和不可预知的问题。</p><img src=" ../../../../images/8051_ell_lib/doc/TMT_2.png" style="zoom:75%;" /><br><h3 id="API手册"><a href="#API手册" class="headerlink" title="API手册"></a>API手册</h3><table><thead><tr><th align="center">函数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>TMT.run</strong>()</td><td align="center">TMT运行</td></tr><tr><td align="center"><strong>TMT.Tick</strong>()</td><td align="center">TMT节拍</td></tr><tr><td align="center"><strong>TMT.Create</strong>(void (*taskFunc) (void),uint16_t triTime)</td><td align="center">创建进程</td></tr><tr><td align="center"><strong>TMT.Delete</strong>(void (*taskFunc) (void))</td><td align="center">删除进程</td></tr><tr><td align="center"><strong>TMT.TimeCtrl</strong>(void (*taskFunc) (void),uint16_t triTime)</td><td align="center">进程时间控制</td></tr><tr><td align="center"><strong>TMT.runCtrl</strong>(void (*taskFunc) (void),PRO_STATE state)</td><td align="center">进程状态控制</td></tr><tr><td align="center">void <strong>TMT_Init</strong>()</td><td align="center">TMT初始化</td></tr></tbody></table><br><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><ol><li>在Lib_CFG文件里，配置相关参数 ；</li></ol><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*--------------------------------------------------------| @Description: STC8x Componets config                   |--------------------------------------------------------*&#x2F;&#x2F;**  * @name    TMT  * @brief   Task time tool***&#x2F;#define  COM_LIB_TMT_CTRL              (1)    &#x2F;&#x2F; &quot;1&quot; 开启, &quot;0&quot;关闭 #define  COM_LIB_TMT_TASK_NUM_MAX      (8)    &#x2F;&#x2F; 最大任务数量#define  COM_LIB_NVIC_TIMER_ISR_ENABLE    ET0 &#x3D; 1  &#x2F;&#x2F;定时器中断打开（根据你使用的定时器来选择）#define  COM_LIB_NVIC_TIMER_ISR_DISABLE   ET0 &#x3D; 0  &#x2F;&#x2F;定时器中断关闭（根据你使用的定时器来选择）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>在定时器中断服务函数里，调用任务时间处理回调函数 ；</li></ol><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;TMT.h&quot;  &#x2F;&#x2F;调用头文件；void TIMER0_ISRQ_Handler(void) &#x2F;&#x2F;定时器0中断服务函数&#123;    &#x2F;*    调用TMT节拍函数，为TMT提供心跳节拍，    节拍时间根据你设置的定时器中断时间来决定    *&#x2F;    TMT.Tick(); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>在自己编写的C文件里，编写一个任务进程。</li></ol><pre class="line-numbers language-C" data-language="C"><code class="language-C">void App_lamp(void) &#x2F;&#x2F;任务进程必须是void型 无形参&#123;    GPIO_TOGGLE_PIN(GPIO_P1,Pin_0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>在main里面调用进程初始化，同时在循环体里面调用TMT运行函数。</li></ol><pre class="line-numbers language-C" data-language="C"><code class="language-C">extern void App_lamp(void);int main(void)  &#x2F;&#x2F;main 函数&#123;STC8x_System_Init(); &#x2F;&#x2F; 调用MCU外设初始化函数  主要初始化定时器，这里给定时器1ms中断一次     TMT_Init();  &#x2F;&#x2F;任务进程初始化函数。if(TMT.Create(Task1_Led,500) &#x3D;&#x3D; FSC_SUCCESS)&#123;DEBUG_LOG(&quot;success&quot;);&#125;else&#123;DEBUG_LOG(&quot;fail&quot;);&#125;for(;;)  &#x2F;&#x2F;无限循环体&#123;TMT.Run();&#x2F;&#x2F; 调用任务进程处理回调函数 &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-概要介绍</title>
      <link href="2021/02/18/8051ell-ku-gai-yao-jie-shao/"/>
      <url>2021/02/18/8051ell-ku-gai-yao-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="8051-ELL函数库简介"><a href="#8051-ELL函数库简介" class="headerlink" title="8051 ELL函数库简介"></a>8051 ELL函数库简介</h2><br><p>ELL是<code>efficient low-layer</code>的缩写，意思是<code>高效低封装</code>，结合了<code>HAL库</code>和<code>LL库</code>的编程思想，既保证了通用性又降低了flash的过度占用。可谓是一举两得，高效、简洁、好用！<br><br></p><p>开发函数库，最初是为了满足我自己的生产需求，后来经过深思熟虑，我想做一个好用的通用库，所以把它开源出来，分享给广大工程师们。<br><br></p><p>函数库是基于Keil开发，支持Keil4和Keil5，支持Vscode协同开发，推荐使用EIDE插件。目前函数库主要适配了STC公司的单片机型号，以STC8系列为主。后续计划增加STC12、STC15、STC16系列。<br><br></p><h2 id="新手如何入门"><a href="#新手如何入门" class="headerlink" title="新手如何入门"></a>新手如何入门</h2><br><p>如果你明白了ELL函数库的架构，那么对你学习本库会有非常大的帮助！函数库采用了一个裸机框架来组织库文件。框架包括两大部分：<code>工程文件</code>和<code>库文件</code>。<br><br></p><p>工程文件主要存放<code>Keil工程</code>、<code>Vscode文件</code>、<code>用户代码</code>。这里可以根据你的编程习惯进行安排，非常的自由！库文件才是我们的重头戏，它主要分为四个部分：<code>核心文件夹</code>、<code>片内外设库</code>、<code>组件库</code>、<code>设备驱动库</code>。<br><br></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">核心文件夹：存放各种MCU的寄存器头文件、函数库重定义数据类型头文件、函数库常用数据结构头文件片内外设库：存放MCU的片内外设模块，是库的主要构成单元。组件库：配套8051内核开发的好用组件，具有一定的抽象性和封装性，能加速项目的开发，比如TMT时间片任务进程组件。设备驱动库：一些常用的外围芯片、模块，通过统一的驱动框架进行封装，方便开发。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>下面是ELL函数库的框架图:<br><br></p><img src=" ../../../../images/8051_ell_lib/doc/ELL-framework.png" style="zoom:75%;" /><br><p>关键的是，我们该如何在工程里面使用函数库呢？我们提供了一个非常便捷的方法！我们拿STC8系列的ELL函数库举例，你只需要调用一个头文件<code>8051_ELL_Lib.h</code>，和配置一个头文件<code>Lib_CFG.h</code>。<br><br></p><p>通过配置<code>Lib_CFG.h</code>，可以实现对库裁剪和控制，定制适合你工程的函数库。而使用函数库内的API，只需要调用<code>8051_ELL_Lib.h</code>就可以了。</p><p>看到这里，如果你对本库产生了兴趣，可以通过下面下载:<br><br></p><blockquote><p><a href="https://gitee.com/zeweni/ELL-8051-LIB">gitee仓库  (需要注册账户下载，速度快)</a></p></blockquote><br><blockquote><p><a href="https://github.com/zewen-i/8051-ELL-LIB">github仓库   (可以直接下载，但速度慢)</a></p></blockquote><br><p>本库是开源项目，遵循 Apache 许可证 2.0 版本，可免费在商业产品中使用，不需要公布应用程序源码，没有潜在商业风险。<br><br></p><p>如果本项目对你有所帮助，可以通过下方的<code>赞赏</code>按钮，请我喝一杯咖啡！<br><br></p><blockquote><p>QQ技术交流群：1001220381</p></blockquote><br><p>我会在群里免费答疑和提供技术支持！</p><br>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8051ELL库-工程创建</title>
      <link href="2021/02/18/8051ell-ku-gong-cheng-chuang-jian/"/>
      <url>2021/02/18/8051ell-ku-gong-cheng-chuang-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="工程框架介绍"><a href="#工程框架介绍" class="headerlink" title="工程框架介绍"></a>工程框架介绍</h2><br><p>ELL库使用的工程框架，是我从实验室一步一步更新迭代出来的，这套框架本身是一个裸机框架，但是稍作修改就能作为RTOS的BSP使用，整个框架的结构非常清晰透彻。如果你深入到工程文件结构观察，会发现整个ELL函数库呈现金字塔状分布：</p><img src=" ../../../../images/8051_ell_lib/doc/8051-ELL函数库-金字塔组成.png" style="zoom:75%;" /><br><p>我们从下往上看，最底层有三个部分，分别是：组件库、片内外设库、设备驱动库，三个库构成我们“金字塔”的基石，是ELL函数库的主要内容。<br><br></p><p>往上一层，是每一个库对应的头文件，这些头文件的作用是把三个库里面的模块文件连接起来。<br><br></p><p>再往上一层，是我们的配置头文件，这个文件比较特殊，需要我们自己实现，但是你不要担心，直接拷贝我们的模板工程里提供的就可以，在配置头文件里，主要修改库的一些属性和参数，比如指明我们使用的MCU型号，使能某些组件和设备驱动，这个头文件如果不加入到你的工程种，那么库将会按照默认的配置执行。<br><br></p><p>最上面一层，是我们整个ELL函数库的头文件，它的作用是把所有模块链接起来，所以我们只要调用这一个头文件，就可以使用库里面的所用模块，当然有些功能需要在配置头文件里修改参数才能启动。<br><br></p><h2 id="框架设计哲学"><a href="#框架设计哲学" class="headerlink" title="框架设计哲学"></a>框架设计哲学</h2><br><p>在这里你可能有疑问，为什么我要设计一个这样的工程框架，或者说叫裸机框架（和RTOS的BSP做区分）？<br><br></p><p>我刚开始写代码的时候，都是用一个头文件包罗万象，各种模块从到到尾全都丢到一起include，方便又省事。但这样的结果是，导致工程管理混乱，代码写得越多，一出问题就越难排查。<br><br></p><p>所以考虑到以上种种问题，我做了这样的设计，ELL函数库的每一个模块必须是独立的，各模块之间的耦合性要降到最低。在C语言里，管理模块之间的联系，最好的办法是通过头文件来实现，但这里我们要注意一些细节：</p><blockquote><p>头文件尽量不要重复包含。尽管我们有预编译指令<code>#ifndef</code>，但我还是建议从源头就规避，因为我们要考虑编译器是如何执行编译的，给编译器减轻负担，就是给我们提高编译效率和速度。</p></blockquote><blockquote><p>头文件的包含，一定要有层级概念。最好是一层一层的包含上去，最底层的不要包含最上层的头文件，就好比我们库金字塔结构的示意图，最下面一层的C文件里，不能包含最顶层库的头文件。在Keil C51里，头文件任意包含，很容易出现问题，导致编译失败，包含的头文件越多越复杂，越容易出现问题。</p></blockquote><br><p>除了头文件，我们对源文件也要采取一定的管理措施。最基本的就是高内聚低耦合，减少全局变量的使用，即使用到全局变量，也尽量缩小其作用域，限制在本模块以内。<br><br></p><p>如果遇到模块之间的配合调用，那么我们需要把相关信息，封装在头文件内，如果需要跨文件调用函数，那么被调用函数的作用域，要仅限在作用函数以内。<br><br></p><h2 id="从零开始建工程"><a href="#从零开始建工程" class="headerlink" title="从零开始建工程"></a>从零开始建工程</h2><br><p>接下来我们讲工程的建立，这里使用的方法，适用于所有的51单片机。正式开始之前，我先讲一些Keil-C51的软件功能，帮大家补一些知识盲区，还有平常不注意的地方，这也是接下来建工程会用到的知识。<br><br></p><ul><li><strong>Keil C51 的版本问题</strong><br></li></ul><p>老工程师比较喜欢用Keil4，因为它简单易用。但Keil4有一些功能缺陷，尤其是代码编写方面，非常令人头疼。它没有代码补全、中文字符字符编码容易乱码、稳定性“差”。我觉得稳定性不是Keil4的错，这要归结于对操作系统的兼容性，很多老软件都有这种问题。<br><br></p><p>那Keil5就足够优秀了吗，不见得。依旧没有代码补全功能，因此在库开发，常遇到使用大量API函数时，对于没有代码补全的IDE来说，是非常麻烦的。<br><br></p><p>但是，作为一名好的工程师，我们的能力，就体现在把不好用的工具用好了！所以在正确看待IDE的不足以后，我们要好好珍惜那些它做的还不错的地方。<br><br></p><ul><li><strong>Keil C51 的预备知识</strong><br></li></ul><p>不管是Keil4 还是Keil5 我们都要搞明白，同一个版本的Keil有好几个方向，有面向8051的、有面向ARM的等等。对于8051内核的MCU，我们要选择安装Keil C51的IDE。<br><br></p><p>安装Keil4和Keil5都可以，但是要注意，Keil4的版本尽量选择新一点，一定要包含LX51功能,如果你不知道如何选择，我给你推荐一个版本Keil C51 V901，可以加QQ群<code>1001220381</code>免费获取，Keil5的话就随你自己选择了,我们库开发使用的是 Keil C51 V960，加群同样可下载。<br><br></p><p>为什么一定要包含LX51功能？这就要讲一下Keil的编译需要那些模块来完成。</p><blockquote><ul><li>C51国际标准化C交叉编译器：<br>从8051C源代码产生可以重定位的目标模块</li></ul></blockquote><blockquote><ul><li>BL51连接器/定位器：<br>组合由C51和A51产生的可重定位的目标模块，产生绝对目标模块。 </li></ul></blockquote><blockquote><ul><li>A51宏编译器：<br>从8051汇编源代码代码产生就可以重定位的目标模块</li></ul></blockquote><blockquote><ul><li>OH51目标文件至Hex格式的转换器：<br>从绝对目标文件生成Hex文件</li></ul></blockquote><p>通过上述功能模块，就能实现Keil最基本的定位目标模块、链接、生成Hex烧录文件等编译流程。这其中的BL51、A51就是我们做学问的地方。一般情况下，Keil会把我们源文件内的所有代码都编译出来（预编译部分除外），但这会导致最后生成Hex文件过大。<br><br></p><p>有的人会选择，把没用到的代码注释掉，来解决这个问题。但对于库开发来说，这样是出力不讨好的。解决办法也很简单，只需要在配置界面的【BL51 Misc】中<strong>Misc control</strong>框内输入:<code>NOOVERLAY</code>即可。<br><br></p><img src=" ../../../../images/8051_ell_lib/doc/BL51.jpg" style="zoom:75%;" /><br><p>然而，这样的效果并没有太好，编译后的Hex文件仍然不小（虽然可以调整优化等级，但是不建议级别太高）。幸好Keil为我们提供了解决办法：</p><blockquote><ul><li>LX51连接器/定位器：<br>BL51的超集，提供更完善更优化的代码链接功能，生成的Hex文件大大减小（相比之下有8%的体积优化）。 </li></ul></blockquote><blockquote><ul><li>AX51宏编译器：<br>A51的超集，提供更完善更优化的代码编译功能，生成的Hex文件大大减小。</li></ul></blockquote><p>除此之外，<strong>LX51链接器</strong>最多可支持8 Mbytes的 代码和8 Mbytes的空间数据，能编译更大的源代码。<br><br></p><p>同时提供详细数据类型检查，在编译生成的所有程序目标中包含详细的信息(如变量、函数、函数的参数列表、单元、结构，等等)。 LX51链接器在目标模块中进行比较并报告任何不匹配。 这有助于在函数的声明或结构或变量中找到细微的错误。<br><br></p><p>尽管如此，我们还需要一点配置手段，才能让<strong>LX51链接器</strong>只编译我们调用过和相关联的代码。在配置界面的【LX51 Misc】中<strong>Misc control</strong>框内输入:<code>REMOVEUNUSED</code>即可。<br><br></p><img src=" ../../../../images/8051_ell_lib/doc/LX51.jpg" style="zoom:75%;" /><br><p>好了，在了解Keil如何编译工程以后，我们就可以开始建立工程了。这里提供三种方法，分别是Keil工程创建、VsCode协同开发、VsCode工程创建。你可以根据自己的喜好来选择，但不管怎么样，都需要你先创建一个Keil工程。</p><blockquote><p>Keil工程创建</p></blockquote><ul><li>准备工作：Keil4或Keil5、STC-ISP助手、8051 ELL函数库</li><li>优点：提供丰富细致的配置，完善的debug、仿真、烧录功能</li><li>缺点：没有代码补全，交互界面陈旧</li></ul><br><p>这里我选择Keil5，STC-ISP助手v6.88，如果你怕出现问题，就选择和我一样的版本,STC型号选择STC8A8K64S4A12。<br><br></p><p><strong>1. 安装STC的芯片包</strong><br><br></p><p>打开STC-ISP助手，选择<code>Keil仿真设置</code>，按照下图操作后，成功就会弹窗<code>STC MCU芯片型号添加成功！</code>。注意，选择Keil的根目录时，只要到最顶层的Keil路径就可以了。<br><br></p><img src=" ../../../../images/8051_ell_lib/doc/STC-ISP-device.jpg" style="zoom:75%;" /><br><p><strong>2. 创建Keil空白工程</strong><br><br></p><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-1.jpg" style="zoom:75%;" /><br><p>在窗口里面选择一个路径，我这里选择桌面，并新建一个文件夹，命名为<code>Keil_Demo</code>。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-2.jpg" style="zoom:75%;" /><br><br></p><p>在gitee或者github仓库下载好ELL函数库，将<code>libraries</code>拷贝过来，同时新建一个文件夹，命名为<code>project</code>。</p><ul><li><a href="https://gitee.com/zeweni/ELL-8051-LIB">gitee仓库  (需要注册账户下载，速度快)</a></li><li><a href="https://github.com/zewen-i/8051-ELL-LIB">github仓库   (可以直接下载，但速度慢)</a></li></ul><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-3-1.jpg" style="zoom:75%;" /><br><p>点击进入project文件夹，新建文件夹<code>build</code>用来存放编译文件，新建文件夹<code>main</code>用来存放MCU初始化文件、新建文件夹<code>app</code>用来我们自己写的代码。最后在输入框给工程起一个名称，这里命名为<code>Demo</code>，然后点击保存（图里面在后面建好了，这里先把文件夹都创建好）。</p><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-3-2.jpg" style="zoom:75%;" /><br><p>Keil工程会跳出Device选择界面，按照下图操作：<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-4.jpg" style="zoom:75%;" /><br><br></p><p>选择否，不需要添加汇编文件（这是一个启动文件，这里不需要）。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-5.jpg" style="zoom:75%;" /><br><br></p><p>点击左上方的魔术棒，我们来配置工程的基本属性，从左到右依次点击选项卡。先选择<code>Target</code>，按图进行配置。根据STC8A的内存容量，所以我们选择XDATA、64Kprogram。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-6.jpg" style="zoom:75%;" /><br><br></p><p>选择<code>output</code>，按图进行操作，要注意必须点击进<code>build</code>文件夹里面，这个路径设置才能生效，这一步主要是为了统一管理输出文件。最后设置好路径以后，别忘了勾选生成Hex文件的复选框。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-7.jpg" style="zoom:75%;" /><br><br></p><p>选择<code>Listing</code>，按图进行操作，同样选择<code>build</code>文件夹的路径，这样我们放在一起，不用额外一个文件夹了。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-8.jpg" style="zoom:75%;" /><br><br></p><p>选择<code>C51</code>，按图中所示步骤，将文件夹<code>libraries</code>下的文件夹路径添加进来，你可以点击这个图放大后进行对照操作，不要有所遗漏。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-9.jpg" style="zoom:75%;" /><br><br></p><p>选择<code>LX51 Misc</code>，在图中所示位置输入<code>REMOVEUNUSED</code>。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-10.jpg" style="zoom:75%;" /><br><br></p><p>选择<code>dewbug</code>,如果你暂时不需要外部硬件调试，可以跳过这一步，如果需要就按图设置，要注意这里还需要点击<code>setting</code>，如果你使用串口仿真调试，就选择对应的COM口，并把波特率设置为115200。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-11.jpg" style="zoom:75%;" /><br><br></p><p>点击左上方图中示意的图标，然后按图创建所示分支，并把每个分支下的内容添加进来，可以点击图片放大观看，方便对应。<br>提示：如果你只需要片内外设库，那么只添加<code>lib/peripheral</code>下对应的C文件就好了。</p><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-12.jpg" style="zoom:75%;" /><br><p>回到主界面，我们双击左边栏目中的main选项分支，就可以添加文件，我们选择之前创建好的main文件夹，在里面创建<code>main.c</code>文件，并添加进来。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-13.jpg" style="zoom:75%;" /><br><br></p><p>在我们的gitee放库中，选择<code>projetc</code>-&gt;<code>STC8Ax</code>-&gt;<code>main</code>-&gt;<code>Lib_CFG.h</code>,拷贝到我们的main文件夹下，并把它添加进来。<br><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-14.jpg" style="zoom:75%;" /><br><br></p><p>在main.c中编写如下代码,并点击左上方的<code>buiid</code>进行编译，如果出现图中端提示的内容，就证明你工程创建成功啦！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;8051_ELL_Lib.h&quot;int main(void)&#123;for(;;)&#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src=" ../../../../images/8051_ell_lib/doc/Keil-project-15.jpg" style="zoom:75%;" /><br><p>按照如上步骤，就可以创建一个ELL函数库工程，如果你不想如此繁琐的创建工程，只需要下载gitee或者github的仓库，里面有现成的Keil工程，直接在此基础上使用即可。</p><p>注意事项：</p><ul><li>工程下的文件，如果变动位置或者修改名称，都需要在Keil的配置界面<code>C51</code>中重新配置该文件或者文件的路径，同时在主界面左边的工程树中，重新导入修改的文件。</li></ul><blockquote><p>VsCode协同开发</p></blockquote><ul><li>准备工作：ELL函数Keil工程一份、VsoCode、VsCode C/C++插件、VsCode Keil Assistant插件</li><li>优点：提供代码补全功能，人机交互做的非常好</li><li>缺点：没有debug功能，需要配合Keil使用，需要通过Keil来向工程添加新的文件，</li></ul><br><p><strong>1. 安装VsCode 插件</strong><br><br></p><p>点击左边的<code>应用商店</code>，安装<code>C/C++</code>、<code>Chinese</code>、<code>Keil Assistant</code>。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-h-1.jpg" style="zoom:75%;" /><br><br></p><p><strong>2. 配置Keil Assistant插件</strong><br><br></p><p>点击<code>Keil Assistant</code>的设置图标,选择<code>扩展设置</code>。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-h-2.jpg" style="zoom:75%;" /><br><br></p><p>导入Keil的执行文件路径，注意路径最后面要加.exe。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-h-3.jpg" style="zoom:75%;" /><br><br></p><p><strong>3. 导入Keil工程，进行协同开发</strong><br><br></p><p>导入Keil工程所在的文件夹。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-h-4.jpg" style="zoom:75%;" /><br><br></p><p>通过图示，点击<code>+</code>按钮，将工程文件打开。注意，不能使用VsCode直接打开Keil工程文件，必须通过这个插件来打开。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-h-5.jpg" style="zoom:75%;" /><br><br></p><p>在Keil Assistant插件的页面，可以对工程进行预览、编译，如果你需要向工程添加文件，需要回到Keil里面操作，Debug也是。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-h-6.jpg" style="zoom:75%;" /><br><br></p><blockquote><p>VsCode工程创建</p></blockquote><ul><li>准备工作：ELL函数Keil工程一份、VsoCode、VsCode C/C++插件、Embedded IDE插件</li><li>优点：提供代码补全功能，人机交互做的非常好，提供多种工具链，可以修改工程，进行编译、调试</li><li>缺点：部分依赖Keil调试的芯片，没有debug功能</li></ul><p><strong>1. 安装VsCode 插件</strong><br><br></p><p>点击左边的<code>应用商店</code>，安装<code>C/C++</code>、<code>Chinese</code>、<code>Embedded IDE</code>。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-P-1.jpg" style="zoom:75%;" /><br><br></p><p><strong>2. 配置Embedded IDE插件</strong><br><br></p><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-P-2.jpg" style="zoom:75%;" /><br><p>打开Keil的根目录，选择<code>TOOLS.INI</code>文件。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-P-3.jpg" style="zoom:75%;" /><br><br></p><p><strong>3. 导入Keil工程，生成EIDE工程</strong><br><br></p><p>按图所示，导入Keil工程。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-P-4.jpg" style="zoom:75%;" /><br><br></p><p>选择与Keil工程放在同一个文件夹下，方便管理项目。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-P-6.jpg" style="zoom:75%;" /><br><br></p><p>修改配置文件，因为我们的工程使用的是STC8A8K64S4A12，所以选择RAM大容量。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-P-6.jpg" style="zoom:75%;" /><br><br></p><p>编译工程，看到如下信息，就表示我们工程创建成功了。<br><img src=" ../../../../images/8051_ell_lib/doc/VsoCode-P-7.jpg" style="zoom:75%;" /><br><br></p><ul><li>补充：EIDE插件还支持SDCC 和stcgal，可以完全脱离Keil开发，如果你感兴趣可以尝试一下。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 8051 ELL函数库指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8051MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Altium Designer 20 笔记（一） 创建工程</title>
      <link href="2021/02/18/altium-designer-20-bi-ji-yi-ad-gong-cheng-zu-cheng-ji-chuang-jian/"/>
      <url>2021/02/18/altium-designer-20-bi-ji-yi-ad-gong-cheng-zu-cheng-ji-chuang-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="Altium-Designer介绍"><a href="#Altium-Designer介绍" class="headerlink" title="Altium Designer介绍"></a>Altium Designer介绍</h2><p>Altium Designer 是原Protel软件开发商Altium公司推出的一体化的电子产品开发系统，主要运行在Windows操作系统。</p><p>这套软件通过把原理图设计、电路仿真、PCB绘制编辑、拓扑逻辑自动布线、信号完整性分析和设计输出等技术的完美融合，为设计者提供了全新的设计解决方案，使设计者可以轻松进行设计，熟练使用这一软件使电路设计的质量和效率大大提高。</p><h2 id="AD20-基本工程介绍"><a href="#AD20-基本工程介绍" class="headerlink" title="AD20 基本工程介绍"></a>AD20 基本工程介绍</h2><p>AD20的工程组成基本如下：</p><img src=" ../../../../images/ad20_note/note1/工程文件组成.jpg" style="zoom:50%;" /><p>一个工程最核心的文件是原理图和PCB，与其相搭配的是这两种文件对应的库，之后是各种生成文件。</p><h2 id="AD20-工程创建流程"><a href="#AD20-工程创建流程" class="headerlink" title="AD20 工程创建流程"></a>AD20 工程创建流程</h2><h5 id="首先，我们要创建一个空的工程项目"><a href="#首先，我们要创建一个空的工程项目" class="headerlink" title="首先，我们要创建一个空的工程项目"></a>首先，我们要创建一个空的工程项目</h5><p>选择 <code>文件</code> -&gt; <code>新的..</code> -&gt;  <code>项目</code></p><img src=" ../../../../images/ad20_note/note1/新建工程.jpg" style="zoom:50%;" /><h5 id="接着，我们要选择工程类型"><a href="#接着，我们要选择工程类型" class="headerlink" title="接着，我们要选择工程类型"></a>接着，我们要选择工程类型</h5><p>选择 <code>PCB</code> -&gt; <code>Default</code></p><img src=" ../../../../images/ad20_note/note1/工程类型页面.jpg" style="zoom:50%;" /><p>一般设计画电路板，我们选择PCB选项。点击到<code>PCB</code>这个选项展开，defult选项是由我们自建工程属性，其他的选项，是软件预先帮我们设计好的demo工程。</p><h5 id="给工程命名和设置存放路径"><a href="#给工程命名和设置存放路径" class="headerlink" title="给工程命名和设置存放路径"></a>给工程命名和设置存放路径</h5><p>选择 <code>PCB</code> -&gt; <code>Default</code></p><img src=" ../../../../images/ad20_note/note1/工程类型页面-配置属性.jpg" style="zoom:75%;" /><p>路径一定要重新设置，默认是指向AD的根目录或者默认的工作区的。</p><p>工程名字根据自己习惯命名。</p><h5 id="给工程创建原理图和库"><a href="#给工程创建原理图和库" class="headerlink" title="给工程创建原理图和库"></a>给工程创建原理图和库</h5><p>选择 <code>文件</code> -&gt; <code>新的..</code> -&gt; <code>库</code> -&gt; <code>原理图库</code> 和 <code>PCB元件库</code></p><p>选择 <code>文件</code> -&gt; <code>新的..</code> -&gt; <code>原理图</code> 和 <code>PCB</code></p><img src=" ../../../../images/ad20_note/note1/主页面-创建库.jpg" style="zoom:75%;" /><p>如果你有自己的库，可以先不创建库，直接创建原理图，后面再把库导入进来。PCB我们也可以不用先创建，画好原理图后，再创建也不迟。</p><p><strong>特别强调，每一个文件建好以后，都要保存 ctrl+s快捷键保存。</strong></p><p>文件保存的路径默认是工程的路径。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><img src=" ../../../../images/ad20_note/note1/工程树.jpg" style="zoom:75%;" /><p>一般我们创建完毕工程以后，就是四个文件：<code>原理图</code>、<code>PCB</code>、<code>原理图库</code>、<code>PCB元件库</code>。后两个库如果有现成的，可以直接导入进来。</p><p>我们在初次创建工程的时候，可能遇到的问题有：</p><ul><li>工程路径没有设置好，导致下次找不到工程文件；</li><li>工程下的各文件是单独建立的，导致各文件没有产生正确的依赖关系，比如原理图无法更新到PCB中；</li><li>文件建立以后，没有及时保存，导致工程树中看不到。</li></ul>]]></content>
      
      
      <categories>
          
          <category> AD20使用指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCB设计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
